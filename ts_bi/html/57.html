
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h3 id="articleHeader1" style="margin-left: 0px;">开篇介绍</h3><p>在上一篇文章中提到了 XML Task 的三种操作方法，分别是 Validate 验证，XSLT 样式表转换，XPath 查询。今天我们继续 XML Task 中剩下的几种操作方法 -  Merge，Diff 和 Patch。</p><h3 id="articleHeader2" style="margin-left: 0px;">Merge 的使用  </h3><p>Merge 操作在 XML 中的用法主要是合并两个 XML 文件的内容到第三个新的文件，或者将第二个 XML 文件的内容插入到第一个文件指定的位置。</p><p>但是 Merge 操作在使用过程中还是有很多地方需要注意的。</p><h4 id="articleHeader3" style="margin-left: 0px;">演示两个 XML 文件内容的合并操作</h4><p>XML 1 的内容</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302318307374418.png"/></p><p>XML 2 的内容，注意 XML 2 中的根节点是没有 TSSalesOrder 的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302318419563611.png"/></p><p>在这个操作中，是将 XML 2 文件中的内容追加到 XML 1 文件中并输出到第三个新的文件 XML_MERGE_1。</p><p>注意 Output 中的配置，将输出的结果保存 SaveOperationResult - True。输出到文件 XML_MERGE_1，并且可以重写覆盖。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302318493476103.png"/></p><p>XML 2 中的内容 Merge 到 XML 1 文件中了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302318598006897.png"/></p><p>如果 XML 2 文件中的内容是这样的，那么这种 Merge 是不能将 &lt;TSSalesOrder&gt; 下的内容合并的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302319075812273.png"/></p><p>默认合并的效果，XML 2 中的 &lt;TSSalesOrder&gt; 也被插入到根节点中。在这种情况下，如果要合并两个 XML 文件相同根结构下的内容就需要通过其它的方式 - 比如先加载两个 XML 文件的内容，最后再统一输出到一个 XML 文件。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302319177535982.png"/></p><p>其实 Merge 的操作主要还是操作这种元素不一致的 XML 文件，比如大段大段的 XML 的合并，两个 XML 文件的内容并不一致。</p><p>比如，要把这段内容</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302319242841643.png"/></p><p>插入到 &lt;TSSalesOrder ID="1002"&gt; 这个节点之下。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302319326759307.png"/></p><p>这个时候就需要按照 XPATH 的查询来指定这个节点的位置 -</p><pre><code><span style='font-family: "Microsoft YaHei"; line-height: 1.5 !important;'>/ORDERS/TSSalesOrder[@ID=<span style='color: rgb(128, 0, 0); font-family: "Courier New" !important; line-height: 1.5 !important;'>'</span><span style='color: rgb(128, 0, 0); font-family: "Courier New" !important; line-height: 1.5 !important;'>1002</span><span style='color: rgb(128, 0, 0); font-family: "Courier New" !important; line-height: 1.5 !important;'>'</span>]</span></code></pre><p style="margin-left: auto;">指定 XML 4 文件往 XML 3 文件合并的时候，合并的位置是 ORDERS 根节点下 TSSalesOrder ID = 1002 的子节点。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302319560815623.png"/></p><p>合并成功，输出到 XML_MERGE_2 文件的效果 - </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302320042376516.png"/></p><p>对于 XML 合并的方式熟悉 C#操作的话是完全可以在 Script Task 中来实现的，直接通过代码访问 XML 文件，然后将内容以追加的方式追加到另外一个 XML 文件中。</p><p>大家可以看看这些例子 - <a href="http://ask.sqlservercentral.com/questions/20899/merge-xml-file.html">http://ask.sqlservercentral.com/questions/20899/merge-xml-file.html</a></p><h3 id="articleHeader4" style="margin-left: 0px;">Diff 的使用</h3><p>XML Task 中的 Diff 操作首先需要有两个 XML 文件来完成，一个是原 XML 文件，一个是被对比的 XML 文件。同时也有两个输出：一个是输出比较的结果，一个是输出比较结果不一致的内容，当然输出是可选的。新建一个包，并选择 XML Task。</p><ol><li>Input 中选择 Diff 操作方式，并选择 ORDER_DETAIL_1.xml 作为源文件。</li><li>Second Operand 是要和药源文件对比的 XML 文件 - ORDER_DETAIL_2.xml </li><li>Output 是指是否需要将对比的结果 True 或者 False 保存起来 (SaveOperationResult)，包括可以选择 DestinationType (文件方式还是变量方式)，文件的话是否每次都覆盖等。</li><li>Diff Options 中的 DiffAlgorithm 比较方法有三种，Auto 就是默认；Fast 快速比较；Precise 精确比较。XML 文件比较大的时候可以选择快速比较，内容比较少的时候需要精确对比的时候可以选择精确比较，通常情况下可以选择默认的 Auto 比较。</li><li>FailOnDifference 表示文件不同的时候是否报错，这里不需要。</li><li>SaveDiffGram 表示是否需要保存对比结果，通常情况下我们是需要的，因为这是分析结果不同的依据。再深一步就是对比的结果做解析进行数据对比，或者人工对比结果。</li><li>对比的结果通过 DiffGramDestination 输出到 DIFF.xml 文件中。</li><li>DiffOptions 中的选项有很多，比如比较的时候是否忽略命名空间，空白等等，可以根据需要来选择。(一般当文件验证能通过之后再做文件内容对比，这些选项是可以忽略的)。 </li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302320441281604.png"/></p><p>直接运行包，先看执行效果然后再来看看这个比较结果能说明什么。</p><p>有两个输出，OperationResult 的结果在实际使用中可以保存到变量中去，这里在文本中可以看到是 False，对比失败。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302320569877098.png"/></p><p>从这个输出结果中可以读取在第一个大节点 &lt;TSSalesOrder&gt; 的第一个，第四个子节点不一致。并且在第四个子节点中它的第二个与第三个子节点也不一致。 </p><ol><li>第一个子节点删除了。</li><li>第四个子节点中的第二个子节点添加了一个 Category 属性，值为 Bikes。</li><li>第四个子节点中的第三个子节点它认为是修改了第三个子节点的名字，变为 UserID，并且 UserID 子节点中的第一个元素(值) 变成了123。</li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302321125664024.png"/></p><p>可以对比一下实际的对比图，上面反应出来的这种不同还是非常非常准确的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302321269723492.png"/></p><p> </p><p>Diff 生成的比较结果文件，实际上可以再次被解析并通过 XPATH 查询可以将不一致的地方自动处理到数据库中，这样就不需要人工的一个一个手动查看和对比了。</p><p>那么这种操作还可以做什么？比如对报表文件，包文件以及任何 XML 格式的文件做更改追踪，记录更改的位置与变化。当然这些过程在项目中完全已经通过 TFS 来管理了，可以很容易的对比到差别。 </p><p>还有一点，比如在 XML 文件对比中，一旦对比结果两个 XML 文件不匹配，通常情况下只会保留第一个 XML 源文件和 Diff 文件就可以了。因为有了源 XML 文件和 Diff 文件，就可以得到另外一个对比的 XML 文件。</p><p>Diff 文件可以通过 XML 源文件 + XML 对比文件得来，那么同样 XML 对比文件也是可以通过 XML 源文件加上 Diff 文件反推过来的。</p><h3 id="articleHeader5" style="margin-left: 0px;">使用 Patch 与 Diff 文件生成源差异文件</h3><p>它的配置比较简单，Input 就是源文件，Second Operand 就是 Diff 文件，Output 就是差异文件。即在上面的操作中，Diff 文件是通过源文件和差异文件对比生成的，现在通过 Patch 操作是可以还原这个差异文件的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302321485978465.png"/></p><p>保存并执行包，查看 PATCH.xml 中的内容。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302321561915785.png"/></p><p>与下方右图的源文件是完全一致的，所以 Diff 和 Patch 是一个互逆的过程。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/302321269723492.png"/></p><h3 id="articleHeader6" style="margin-left: 0px;">更多有关 XML 相关的文章与资源</h3><ol><li><a href="http://www.w3school.com.cn/xpath/" target="_blank">XPath 教程</a></li><li><a href="http://www.w3school.com.cn/xsl/index.asp" target="_blank">XSLT 教程</a></li><li><a href="http://www.w3school.com.cn/dtd/index.asp" target="_blank">DTD 教程</a></li><li><a href="http://www.cnblogs.com/biwork/p/3996560.html" target="_blank">微软BI 之SSIS 系列 - XML Task 中XSLT 样式表转换错误记录</a></li></ol>
</div>]
</body>
</html>
