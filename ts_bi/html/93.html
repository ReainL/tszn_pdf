
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>在 <a href="http://www.flybi.net/blog/biwork/1072"><u><font color="#0066cc">SSAS 系列 - 实现第一个 Cube 以及角色扮演维度，度量值格式化和计算成员的创建</font></u></a> 中主要是通过已存在的维度和事实数据创建了一个多维数据集，并同时解释了 Role-Playing Dimension 角色扮演维度、计算成员、计算成员格式化等内容。在这篇文章中主要是分析和理解在多维数据集设计过程中的聚合函数，对应不同类别的度量值根据需求的不同在聚合函数的选择上也会有所不同。</p><h2 id="articleHeader2">案例实现</h2><p>继续使用在上一篇 SSAS 文章中创建的示例，在 BIWORK_FirstCube 中能看到有两组度量值维度组和各个不同的度量值。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153705-ef800e3322b540ac9c3906f2f41ebfbb.png"/></p><p>选中 Reseller Sales Amount 右键查看属性 AggregateFunction 聚合函数选择的是 SUM 聚合，很好理解就是一个求和的操作。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153718-9c5fb8717ef141dea33d33637972ba9d.png"/></p><p>选中 Reseller Sales Count 右键查看属性，聚合函数选择的是 Count，这个是在创建多维数据集 Cube 的时候自动创建的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153735-6085d992e12b4d4197437acd47bb1167.png"/></p><p>对比一下事实表 FactResellerSales 的结构和在创建 Reseller Sales 和 Internet Sales 度量值组时可供选择的度量值。所有的值类型的数据像 UnitPrice, ProductStandardCost, SalesAmount 这三个列在右侧创建度量值组 Fact Reseller Sales 都出现了，但是多了一个 Fact Reseller Sales Count ，包括在 Fact Internet Sales 下也多出了一个 Fact Internet Sales Count ，很明显是对事实表做了计数统计。因此在 Reseller Sales Count 度量值那里默认使用了 Count 聚合函数，而对于其它的度量值默认使用的是 SUM 函数。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153747-5da9322be8e74cd69841835f9d3762e6.png"/></p><p>先来查看一下 Reseller Sales Amount 和 Reseller Sales Count 的在各个产品分类下的结果是多少。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153805-3ef762eb538b462e95b1df80a2fecd55.png"/></p><p>然后再查询一下数据仓库的数据，看看在多维数据集中的聚合函数是如何完成计算的。</p><pre><code><span style="font-family: Microsoft Yahei; font-size: 14px;"><span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(0, 0, 255);">DISTINCT</span> SalesOrderNumber) <span style="color: rgb(0, 0, 255);">AS</span> SalesOrderCount,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">AS</span> SalesOrderLineCount <br/>
<span style="color: rgb(0, 0, 255);">FROM</span> FactResellerSales<br/>
<br/>
<span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(0, 0, 255);">DISTINCT</span> <br/>
       dpc.EnglishProductCategoryName <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">'</span>,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(fact.SalesAmount) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> dpc.ProductCategoryKey) <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Reseller Sales Amount</span><span style="color: rgb(255, 0, 0);">'</span>,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> dpc.ProductCategoryKey) <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Reseller Sales Count</span><span style="color: rgb(255, 0, 0);">'</span><br/>
<span style="color: rgb(0, 0, 255);">FROM</span> FactResellerSales <span style="color: rgb(0, 0, 255);">AS</span> fact<br/>
<span style="color: rgb(128, 128, 128);">LEFT</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProduct <span style="color: rgb(0, 0, 255);">AS</span> dp<br/>
<span style="color: rgb(0, 0, 255);">ON</span> fact.ProductKey <span style="color: rgb(128, 128, 128);">=</span> dp.ProductKey<br/>
<span style="color: rgb(0, 0, 255);">INNER</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProductSubcategory <span style="color: rgb(0, 0, 255);">AS</span> dps<br/>
<span style="color: rgb(0, 0, 255);">ON</span> dp.ProductSubcategoryKey <span style="color: rgb(128, 128, 128);">=</span> dps.ProductSubcategoryKey<br/>
<span style="color: rgb(0, 0, 255);">INNER</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProductCategory <span style="color: rgb(0, 0, 255);">AS</span> dpc<br/>
<span style="color: rgb(0, 0, 255);">ON</span> dps.ProductCategoryKey <span style="color: rgb(128, 128, 128);">=</span> dpc.ProductCategoryKey</span></code></pre><p>可以看到在 FactResellerSales 事实表中总共有 3796 个订单或者叫做交易，3796 中共有 60855 笔子订单业务。类似于在网店下了一个订单，这个订单上可能包含了不止一种购买的产品。 同时也可以看到 Category 下统计的 Reseller Sales Amount 和 Reseller Sales Count 的结果和在 Cube 中查询的结果是一致的。那么通过这种对比，就知道 SSAS 分析服务在创建多维数据集中是如何将我们的数据进行聚合的。 对于非 Key 类型的数值通常默认以 SUM 方式聚合，并且会额外创建一个度量值并以 COUNT 方式聚合表示事实的条数。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153910-2c194eac1821426e8dd33074fefa1103.png"/></p><h2 id="articleHeader3"><strong>SSAS 中的聚合函数</strong></h2><p>实际上除了 SUM 和 COUNT 之外还有其它的一些聚合函数，在 SSAS 分析服务中我们可以大致将它们分为以下三类：累加性，半累加性和非累加性。</p><p>从这个小例子来理解这些聚合函数 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153930-7319586ff4f847469cf5c5d856b6b9ee.png"/> </p><p><strong>累加性</strong> - 累加性度量值主要是指父级层次结构中成员的值等于它所有子级成员值的总和。</p><ul><li>Sum -  父级成员值等于它所有子级成员值的总和，这是 SSAS 分析服务默认的聚合函数。</li><li>Count - 计算事实表中特殊列非空值的函数，或者计算事实表的行数。父级成员也可以由它的所有子级成员值相加求得。</li></ul><p>很显然交易金额是通过 SUM 聚合函数实现，交易笔数是通过 COUNT 聚合函数实现。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26153956-2f3450a096a6422a8d4fbe3d64337a1c.png"/></p><p><strong>半累加性</strong> - 半累加性度量值只是对某些子级得到进行聚合。</p><ul><li>Max - 父级成员值等于其所有子级中的最小值。</li><li>Min - 父级成员值等于其所有子级中的最大值。</li><li>FirstChild - 父级成员的值等于子级成员值的总和，但是如果在时间维度中，父级成员的值等于第一个子成员的值。</li><li>LastChild - 父级成员的值等于子级成员值的总和，但是如果在时间维度中，父级成员的值等于最后一个子成员的值。</li><li>FirstNonEmpty - 父级成员的值等于子级成员值的总和，但是如果在时间维度中，父级成员的值等于第一个非空子成员的值。</li><li>LastNonEmpty - 父级成员的值等于子级成员值的总和，但是如果在时间维度中，父级成员的值等于最后一个非空子成员的值。</li><li>AverageOfChildren - 对多维数据集时间维度中最低粒度级别的所有维度进行求和，然后再求平均值，即得所求值。(非空子成员)</li><li>ByAccount - 当多维数据集包含一个账户类型的维度时，需要使用按账户聚合函数。度量值的按账户聚合函数是维度 Account 成员的一个属性。</li></ul><p>比如在这里最大交易金额是通过 MAX 聚合的，最小交易金额是通过 MIN 聚合的，开始库存在时间维度上应该找第一个非空成员使用到了 FirstNonEmpty 聚合函数，而最后库存在时间维度上应该找最后一个非空成员的值。因为库存在实际业务中是不会进行累加操作的，每天开始的库存和每天结束的库存也是不一样的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154034-23ab5ae3236e49c99fa5acba6534918d.png"/></p><p><strong>非累加性</strong> - 父级成员的值不能由自己的值得到。</p><ul><li>DistinctCount - 非重复计算，对事实表中无重复的列进行计数，成员值是通过对该成员的无重复技术而确定的。</li><li>NONE  - 不进行任何聚合。</li></ul><p>如果在订单上进行 DistinctCount，那么订单就是4笔，因为 D001 算一笔订单，在这笔订单里有两条订单明细信息。</p><h2 id="articleHeader4">聚合函数的使用</h2><p>那么有了这些基础知识之后，我们可以添加或者修改多维数据集中的度量值并提供合适的聚合函数了。</p><p>接着上面的项目，在多维数据集设计中选择 Reseller Sales 右键添加新的度量值。</p><p>创建一个度量值 Maximum Sales Amount -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154152-025259f702e74a66974efe5ec2efe5f6.png"/> </p><p>非空订单总数量 - Product Key Count</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154210-71bc830ccb69421ba1642bea94f1c87a.png"/></p><p>在 Usage 中有 Count of non-empty values (非空值计数) 和 Count of rows (行计数)，它们的区别是行计数应用到事实表各行，而非空值技术应用到事实表各列。</p><p>Sales Order Number Distinct Count 非重复的订单号</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154231-fdddd21699cc444ab5fc272b930f5fc3.png"/> </p><p>注意在使用非重复计数 Distinct Count 聚合函数的时候，SSAS 会创建一个单独的度量值组。这是因为 SSAS 分析服务处理非重复计数度量值组时，从事实表中选择数据的 SQL 查询会按照非重复计数列来进行排序，以便为非重复计数度量值而进行度量值组的物理数据存储实现优化。 因此，每一个非重复技术度量值都应该被放在单独的度量值组中。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154247-bb46a5bac5b549a8954ad1bf564d1dae.png"/></p><p>保存并部署处理多维数据集，在 Excel 中浏览这些数据。(Reseller Sales Count 是 SSAS 自动创建的， Product Key Count 是我们在这里手动创建的)</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154302-3798c0566ad44d0dbe91d4561cfe5c88.png"/></p><p>使用 SQL 语句在数据仓库中直接查询。</p><pre><code><span style="font-family: Microsoft Yahei; font-size: 14px;"><span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(0, 0, 255);">DISTINCT</span> <br/>
       dpc.EnglishProductCategoryName <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">'</span>,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(fact.SalesAmount) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> dpc.ProductCategoryKey) <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Reseller Sales Amount</span><span style="color: rgb(255, 0, 0);">'</span>,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> dpc.ProductCategoryKey) <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Reseller Sales Count</span><span style="color: rgb(255, 0, 0);">'</span>,<br/>
       <span style="color: rgb(255, 0, 255);">MAX</span>(fact.SalesAmount) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> dpc.ProductCategoryKey) <span style="color: rgb(0, 0, 255);">AS</span> <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">MAX Sales Amount</span><span style="color: rgb(255, 0, 0);">'</span> <br/>
<span style="color: rgb(0, 0, 255);">FROM</span> FactResellerSales <span style="color: rgb(0, 0, 255);">AS</span> fact<br/>
<span style="color: rgb(128, 128, 128);">LEFT</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProduct <span style="color: rgb(0, 0, 255);">AS</span> dp<br/>
<span style="color: rgb(0, 0, 255);">ON</span> fact.ProductKey <span style="color: rgb(128, 128, 128);">=</span> dp.ProductKey<br/>
<span style="color: rgb(0, 0, 255);">INNER</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProductSubcategory <span style="color: rgb(0, 0, 255);">AS</span> dps<br/>
<span style="color: rgb(0, 0, 255);">ON</span> dp.ProductSubcategoryKey <span style="color: rgb(128, 128, 128);">=</span> dps.ProductSubcategoryKey<br/>
<span style="color: rgb(0, 0, 255);">INNER</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimProductCategory <span style="color: rgb(0, 0, 255);">AS</span> dpc<br/>
<span style="color: rgb(0, 0, 255);">ON</span> dps.ProductCategoryKey <span style="color: rgb(128, 128, 128);">=</span> dpc.ProductCategoryKey</span></code></pre><p>结果是一样的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154342-8b8d655536a0418e98610f306da3a0cb.png"/></p><p>再来按年浏览一下订单数量和订单明细的数量，例如 CY2005 年共有366个订单，366个订单共计 4138 个订单明细。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154358-97fb4e4fabd04c1e8c44415447734774.png"/></p><p>在数据仓库中直接查询 Fact 表和 Dimension 表的结果也是一样的。</p><pre><code><span style="font-family: Microsoft Yahei; font-size: 14px;"><span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(0, 0, 255);">DISTINCT</span> <br/>
       dt.CalendarYearKey,  <br/>
       ( <br/>
            <span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(0, 0, 255);">DISTINCT</span> f.SalesOrderNumber) <span style="color: rgb(0, 0, 255);">AS</span> OrderCountByYear<br/>
            <span style="color: rgb(0, 0, 255);">FROM</span> FactResellerSales <span style="color: rgb(0, 0, 255);">AS</span> f<br/>
            <span style="color: rgb(128, 128, 128);">LEFT</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimDate <span style="color: rgb(0, 0, 255);">AS</span> d<br/>
            <span style="color: rgb(0, 0, 255);">ON</span> f.OrderDateKey <span style="color: rgb(128, 128, 128);">=</span> d.DateKey <br/>
            <span style="color: rgb(0, 0, 255);">WHERE</span> d.CalendarYearKey <span style="color: rgb(128, 128, 128);">=</span> dt.CalendarYearKey<br/>
            <span style="color: rgb(0, 0, 255);">GROUP</span> <span style="color: rgb(0, 0, 255);">BY</span> d.CalendarYearKey<br/>
       )<span style="color: rgb(0, 0, 255);">AS</span> OrderNumberCount, <br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> CalendarYearKey) <span style="color: rgb(0, 0, 255);">AS</span> OrderDetailCount<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> FactResellerSales <span style="color: rgb(0, 0, 255);">AS</span> fact<br/>
<span style="color: rgb(128, 128, 128);">LEFT</span> <span style="color: rgb(128, 128, 128);">JOIN</span> DimDate <span style="color: rgb(0, 0, 255);">AS</span> dt<br/>
<span style="color: rgb(0, 0, 255);">ON</span> fact.OrderDateKey <span style="color: rgb(128, 128, 128);">=</span> dt.DateKey <br/>
<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> dt.CalendarYearKey </span></code></pre><p><img alt="" src="http://images.cnitblog.com/blog/477275/201312/26154419-99aeddf31b1e42aba48a6a376b09eae5.png"/></p><h2 id="articleHeader5">关于测试</h2><p>另外，要补充一点。像 BI 项目的测试与其它项目的测试不太一样，因为更多的关于数据方面的清理，整理与转换。但是在数据仓库级别和 Cube 级别的数据比较，从我的这篇文章中应该可以看到一些方法与技巧。也就是无论是数据仓库还是多维分析数据库它们都是数据的一个容器，因此可以通过 SQL 语句直接在数据仓库中查询最原始的数据，然后与从 Cube 中无论从 MDX 还是 Excel 中出来的维度关联事实数据进行对比就可以了。</p><p>原因很简单，一种是基于数据仓库的 SQL 查询  (数据仓库 - Select 查询结果集) , 一种是基于数据仓库的多维数据集 (数据仓库 - Cube - Excel 或者 MDX)，基于的都是同一个数据源，那么就比较它们各自的查询结果就知道数据是否是预期的了。</p><p>以后有时间专门再写一篇有关 BI 项目的测试过程，阶段分解以及测试的方法等。<br/></p>
</div>]
</body>
</html>
