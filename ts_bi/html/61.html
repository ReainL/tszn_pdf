
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>SSIS Data Flow 中有几个组件可以实现不同数据源的数据合并功能，比如 Merger, Merge Join 和 Union All。它们的功能比较类似，同时也比较容易混淆，下面是对它们之间的区别的对比总结。</p><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212429-6b26a4f93b5c4b16a1bc64889517aa29.png"/></p><p>下面通过三个 Data Flow 来演示这三个组件的使用以及相关的配置。</p><h2 id="articleHeader2">测试数据源</h2><p>第一个数据源是一张表</p><pre><code><span style="color: rgb(0, 0, 255);">USE</span><span style="color: rgb(0, 0, 0);"> BIWORK_SSIS<br/>
</span><span style="color: rgb(0, 0, 255);">GO</span><br/>
<br/>
<span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> Merge demo table</span><br/>
<span style="color: rgb(0, 0, 255);">IF</span> <span style="color: rgb(255, 0, 255);">OBJECT_ID</span>(<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">DEMO_MG_Customer</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">U</span><span style="color: rgb(255, 0, 0);">'</span>) <span style="color: rgb(0, 0, 255);">IS</span> <span style="color: rgb(128, 128, 128);">NOT</span> <span style="color: rgb(0, 0, 255);">NULL</span><br/>
<span style="color: rgb(0, 0, 255);">DROP</span> <span style="color: rgb(0, 0, 255);">TABLE</span><span style="color: rgb(0, 0, 0);"> DEMO_MG_Customer<br/>
</span><span style="color: rgb(0, 0, 255);">GO</span><br/>
<br/>
<span style="color: rgb(0, 0, 255);">CREATE</span> <span style="color: rgb(0, 0, 255);">TABLE</span><span style="color: rgb(0, 0, 0);"> DEMO_MG_Customer<br/>
(<br/>
  CustomerID </span><span style="color: rgb(0, 0, 255);">INT</span> <span style="color: rgb(0, 0, 255);">PRIMARY</span> <span style="color: rgb(0, 0, 255);">KEY</span><span style="color: rgb(0, 0, 0);">,<br/>
  CustomerCompany </span><span style="color: rgb(0, 0, 255);">NVARCHAR</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">255</span><span style="color: rgb(0, 0, 0);">),<br/>
  CustomerName </span><span style="color: rgb(0, 0, 255);">NVARCHAR</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">20</span><span style="color: rgb(0, 0, 0);">),<br/>
  CustomerAddress </span><span style="color: rgb(0, 0, 255);">NVARCHAR</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">255</span><span style="color: rgb(0, 0, 0);">)<br/>
)<br/>
<br/>
</span><span style="color: rgb(0, 0, 255);">INSERT</span> <span style="color: rgb(0, 0, 255);">INTO</span> DEMO_MG_Customer <span style="color: rgb(0, 0, 255);">VALUES</span><span style="color: rgb(0, 0, 0);"><br/>
(</span><span style="color: rgb(128, 0, 0); font-weight: bold;">1</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">HFBZG</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Allen,Michael</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Obere Str. 0123</span><span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(0, 0, 0);">),<br/>
(</span><span style="color: rgb(128, 0, 0); font-weight: bold;">2</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">MLTDN</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Hassall, Mark</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Avda. de la Constitución 5678</span><span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(0, 0, 0);">),<br/>
(</span><span style="color: rgb(128, 0, 0); font-weight: bold;">3</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">KBUDE</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Peoples, John</span><span style="color: rgb(255, 0, 0);">'</span>,<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">Mataderos  1000</span><span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(0, 0, 0);">)<br/>
<br/>
</span><span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(128, 128, 128);">*</span> <span style="color: rgb(0, 0, 255);">FROM</span> DEMO_MG_Customer</code></pre><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212527-d7e0efb4d4194469a8c19b73b576186e.png"/></p><p>第二个数据源是一个文本文件</p><p>ID,Company,CustomerName,Title,Address</p><p>1,'NRZBB','Allen,Michael','Sales Representative','Obere Str. 0123'</p><p>2,'MLTDN','Hassall, Mark','Owner','Avda. de la Constitución 5678'</p><p>3,'KBUDE','Peoples, John','Owner','Mataderos  7890'</p><p>4,'HFBZG','Arndt, Torsten','Sales Representative','7890 Hanover Sq.'</p><p>5,'HGVLZ','Higginbotham, Tom','Order Administrator','Berguvsvägen  5678'</p><h2 id="articleHeader3">示例一 - 使用 Merge 来合并数据</h2><ul><li>上面已经说了 Merge 的特点-</li><li>输入数据源 - 两个</li><li>输入数据源 - 表或者文件等</li><li>合并时要求元数据相同，数据类型相同</li><li>合并前需要排序</li></ul><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212543-bccf2cd166bb443185359f33034cd91f.png"/></p><p>合并操作类似于 SQL 语句中的 UNION ALL。</p><p>OLE_SRC_Customer - OLE DB Source 中指定的数据源来自 BIWORK_SSIS 数据库中的 dbo.DEMO_MG_Customer 表。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212558-8d09d3066ab54eeb883cbea3aeea332d.png"/></p><p>表中的 5 个列都将作为输出列向下输出。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212608-da8f8a9d6efa4f40b503ad048f1cfe3b.png"/></p><p>FF_SRC_Customer (Flat File Source) 的 Flat File Connection Manager 指向文本文件源。并且要注意 Text qualifier 是'， 因为要注意到文本文件中位于 '  ' 之间的才是真正要处理的文本。</p><p>1,'NRZBB','Allen,Michael','Sales Representative','Obere Str. 0123'</p><p>并且指明文本文件中的第一行是列标题。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212643-78ffe02cea154a3caead4286ea5393e3.png"/></p><p>逗号分割列</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212734-05176d6bad64417d90b0fb3d88caa926.png"/></p><p>在这里要注意的是文本文件中 ID 的数据类型指定 DT_I4 来映射 SQL Server 数据库中的INT 类型，否则两个数据源一旦有一个列数据类型不一致的话，那么合并操作时就会出现错误。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212756-cbb8a5c7ba8645aea77082b48711eb9b.png"/></p><p>其它字符串用 DT_WSTR 即可，因为要和数据库中的 NVARCHAR 数据类型匹配。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212812-5a1a7e62bbf34e0a9e1622f5fae7d6dd.png"/></p><p>注意在 Flat File Source 向下输出的时候并没有选择 Title, 因为这一列在 Input Table Source 中并不存在。在合并两个来自不同数据源的时候，我们要求两边的元数据一致，即列的数量和类型也应该一致。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212845-e95dcb9b0c13401891ab61a8771d57df.png"/></p><p>因为本身 ID 就是有序的，所以为了演示的效果选择 CustomerName 作为排序列，两边的源的拍序列也应该选择一致。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212900-240afec47b48420b973e9c4250516cfe.png"/></p><p>Merger Transformation 列出了输出的列，两个输入源并且显示了它们的排序列，最终输出的结果也会按照 CustomerName 排序的结果来输出。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212916-5c332e7889ce4897809383dc36f48e97.png"/></p><p>Merge 之后来自于两个不同数据源的数据就合并到了一起，并且 CustomerID = 2 的数据分别来自两个数据源，内容也是一致的，但并没有在合并的时候删除重复的数据，这类似于 SQL 语句中的 UNION ALL 的操作，保留了重复项。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212928-9166f25f62f4414e8f21fdd22dfa2c61.png"/></p><h2 id="articleHeader4">示例二 - 使用 Merge Join 组件合并数据</h2><p>Merge Join 类似于 SQL 中的 Full/Left/Inner Join 等操作，因为不需要两边数据源的元数据一致。但是，它也要求左右两边的数据源排序，并且排序列必须包含后面使用到的 JOIN 列。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212941-d426feacfb7b45cb8009189d1338031f.png"/></p><p>前面的配置和上一个例子中一样，只是排序列改成了 CustomerID，只看 Merge Join 部分。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08212953-338046e160b14761a58ca8526d75813f.png"/></p><p>除了 Inner Join 外，还有 Full Join 和 Left Outer Join 等同于 SQL 中的 Inner Join/Full Join/Left Join 等操作。</p><p>看上面图片中显示了左右两边的数据源，其中 Join Key 必须包含在排序列中。在左边的表数据源中有4个输出列，与右边文件中的 Title 输出列共同组成了5个输出列。</p><p>如果使用 SQL 语句来表示这里的逻辑，可以理解成-</p><pre><code><span style="color: rgb(0, 0, 255);">SELECT</span><span style="color: rgb(0, 0, 0);"> tbl.CustomerID,<br/>
            tbl.CustomerCompany,<br/>
            tbl.CustomerName,<br/>
            tbl.CustomerAddress,<br/>
            ff.Title<br/>
</span><span style="color: rgb(0, 0, 255);">FROM</span> ST_TBL_Customer <span style="color: rgb(0, 0, 255);">AS</span><span style="color: rgb(0, 0, 0);"> tbl<br/>
</span><span style="color: rgb(0, 0, 255);">INNER</span> <span style="color: rgb(128, 128, 128);">JOIN</span> ST_FF_Customer <span style="color: rgb(0, 0, 255);">AS</span><span style="color: rgb(0, 0, 0);"> ff<br/>
</span><span style="color: rgb(0, 0, 255);">ON</span> tbl.CustomerID <span style="color: rgb(128, 128, 128);">=</span> ff.ID</code></pre><p>从这里看出 Inner Join 能关联上3条数据，其中 Title 列来源于文件数据源。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213005-a1fe263213344720b9deb27664e22cad.png"/></p><p>在这里，也可以使用 Merge Join 组件完成对已存在的数据进行更新，对不存在的数据进行插入操作。比如可以使用 Left Outer Join, 假设以左表为目标表的话，那么就能够利用关联上 ID 的右文件数据源来更新左表，关联不上的就作为新数据插入到左表中。只需要在 Merge Join 下加一个 Conditional Split 组件来判断即可，可以参考我的另一篇文章 -</p><p><a href="http://www.flybi.net/blog/biwork/531"><u><font color="#0066cc">SSIS 系列 - Lookup 组件的使用与它的几种缓存模式 - Full Cache, Partial Cache, NO Cache</font></u></a></p><h2 id="articleHeader5">示例三 - 使用 UNION ALL 组件合并数据</h2><p>UNION ALL 组件与上面两个组件最大的区别就是，一可以合并两个以上的数据源，二是不需要对数据源进行排序。</p><p>这个示例中有三个数据源，前两个和上面示例中的配置一样，第三个数据源和第二个数据源实质上相同，都是指向同一个数据表。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213156-4487c78477424b2ba776e054be1d9334.png"/></p><p>直接看 UNION ALL 组件的配置，非常的简单。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213215-66d3a92d878f45b48b5c39028e96926d.png"/></p><p>看到输出列了吗？ 默认情况下将第一个文件数据源的列作为默认的整个组件的输出列，如果后面的数据源没有这些列的话，那么就忽略掉，其它的列再一一设置匹配一下，当然数据类型应该一致。</p><p>输出的结果如下，有重复的数据并且也未排序。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213233-4935a55eb34c4e7dba5e4f1a072f3bd2.png"/></p><h2 id="articleHeader6">三个组件各自不同的特点</h2><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213341-ad8490550c514736b78f6b8c423f50a9.png"/></p><p>简单的可以归纳一下何时应该选择 Merge, Merge Join 和 Union All 组件来合并不同数据源的数据呢？</p><ul><li>如果有两个以上的数据源 - UNION ALL</li><li>如果只有两个数据源，并且是从两个不同数据源基于一些关联条件各取一部分数据 - Merge Join</li><li>如果只有两个数据源，目的为了合并而非关联 - UNION ALL/Merge</li><li>如果只有两个数据源，目的只为了合并但不需要输出的结果排序 - UNION ALL</li><li>如果只有两个数据源，目的只为了合并但需要输出的结果排序 - Merge</li></ul><h2 id="articleHeader7">Asynchronous Transformation VS  Synchronous Transformation </h2><p>当然，除此之外还有些细节需要知道的是 - 尽量避免使用 Sort 排序组件，原因在于 Sort 排序组件被称之为 Asynchronous Transformation。</p><p>Asynchronous Transformation 非同步转换 - Blocked Transformation 阻塞转换。Sort 排序组件就属于这一类，和它相同的还有 Pivot 组件。</p><p>它们处理数据的过程是先从上游数据源中抽取所有数据，再开始处理排序，全部排序完成之后再产生输出。这样的过程极大的消耗了内存并且使得整个处理的过程变得缓慢。</p><p>相对于这类组件，有一类组件是属于  Synchronous Transformation 同步转换，比如：</p><ul><li>Derived Column</li><li>Copy Column</li><li>Data Conversion</li></ul><p>这类组件基本上是从数据源一条一条的取，一条一条的处理并同时输出给下游转换组件。</p><p>所以在上面的几个示例中，更优的选择应该是在 OLE DB Source 的操作中使用 SELECT 语句加上排序操作来代替直接使用表或者视图，这样避免转换阻塞。</p><p>因此对示例一做出一些修改，去掉中间的排序组件。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213434-183bbfe7413842b3a2d1d5b2dcc398ca.png"/> </p><p>在 OLE_SRC_Customer 中使用 SELECT 语句加上排序操作使得输出是已经排好序的结果。</p><pre><code><span style="color: rgb(0, 0, 255);">SELECT</span><span style="color: rgb(0, 0, 0);"> CustomerID,<br/>
       CustomerCompany,<br/>
       CustomerName,<br/>
       CustomerAddress<br/>
</span><span style="color: rgb(0, 0, 255);">FROM</span><span style="color: rgb(0, 0, 0);"> dbo.DEMO_MG_Customer<br/>
</span><span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> CustomerName</code></pre><p>但是再次连接到  Merge 组件上时会发生错误，因为你还要通知一下 Merge 组件你是如何排序的。</p><p>右键 OLE_SRC_Customer 选择 Advanced Editor，在 Input and Output Properties 这里修改一下 IsSorted 属性，设置为 True, 默认是 False。 这样就告诉了下游转换组件，这里的结果是已经排好序的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213523-3d683b0bc34b4a21a5d0165d3dcd50a0.png"/></p><p>同时还需要指定如何排序，按照哪些列来排的序。因为在示例 Merge 中我们选择的是 Customer Name, 因此这里将它的 0 修改为1。 0 表示是不排序的，1 表示是第 一个排序位，这里应该按照 ORDER BY 后面的列顺序来设置，第二个排序列就设置为 2， 依此类推。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213537-f565a9c126e6470696bc4434aabf350f.png"/></p><p>修改完毕后，再运行一下第一个示例，结果是一样的<img alt="" src="http://images.cnitblog.com/blog/477275/201309/08213556-0a420526eefc40cda714836a6a2beb53.png"/></p><p> 这里的数据量比较少，可以试一下10W级，100W级 以上使用 Sort 组件和不使用 Sort 组件的差别来体会一下这两种处理方式的不同。<br/></p>
</div>]
</body>
</html>
