
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>Execute SQL Task 这个控件在微软BI ETL 项目中使用的频率还是非常高的，也是大部分入门 SSIS 初学者最早接触到的几个控制流控件。</p><p>我们通常使用 Execute SQL Task 的场景包含但不止于以下几类：</p><ol><li>在从源端加载数据到 Staging 表之前使用 Execute SQL Task 执行一些 Truncate 操作。</li><li>执行一些 Log 的插入，更新操作。</li><li>ETL 过程中的 Merge 语句操作。</li><li>XML 的输出处理。</li></ol><p>关于如何使用 Execute SQL Task 就不在本文讲解了，包括参数传递 Input，存储过程返回值 Output，包括 Return Value ，还有 SQL Source Type 等不同方式以及 OLD DB，ADO.NET 区别等基础概念文本也不会涉及到。</p><p>本文要讲解的内容是针对 ResultSet 的几种类型：None, Single row, Full result set, XML。其中 None 不用讲解，关于 XML 的内容大家可以参考我的另一篇文章 <a href="http://www.flybi.net/blog/biwork/605" target="_blank"><u><font color="#0066cc">两种将 SQL Server 数据库数据输出成 XML 文件的方法</font></u></a>，因此在这里只讲解 Single Row 和 Full Result Set 的处理方法。 </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041700437665132.png"/></p><h2 id="articleHeader2">Single Row  </h2><p>首先，Single Row 指的就是在 Execute SQL Task 中返回的就是一个单行的记录，允许多列。</p><p>通常在 Execute SQL Task 中使用 Single Row 的时候是为了在控制流中控制流程的流转，满足一定的条件走一个分支流程，不满足则走另外一个流程。</p><p>比如，在包执行之初查询数据库检查一下包的某些状态，或者数据的某些状态，只有在满足达到一定条件下才能执行剩下的流程，否则则不执行包或者报错。这类设计在各种不同的BI项目中可能都存在，那么其原型就是利用 Execute SQL Task 中的 Single Row返回的值来控制流程。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041701171251407.png"/></p><p>有以下几个步骤：</p><ol><li>SQL Statement 中的语句返回单行记录，可以多列。</li><li>需要在包中实现定义变量用来接收 Single Row 的某列上的值。</li><li>使用 Precedence Constraint 和变量来控制流程。</li></ol><h3 id="articleHeader3">Single Row 案例</h3><p>一条简单的查询语句返回一个单行双列的记录。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041701508913325.png"/></p><p>设置好连接并放好SQL语句，选择 Single Row。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702009074131.png"/></p><p>添加三个变量</p><ol><li>EXISTING_COUNT - 用来接收查询中的返回的COUNT数。</li><li>MAX_DATE - 用来接收查询中返回的最大时间。</li><li>TEST_DATE - 测试时间，比如说 2014-01-01。</li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702174381749.png"/></p><p>0 表示 Single Row 中的第一列，1 表示 Single Row 中的第二列。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702335781250.png"/></p><p>下面放两个空的 Data Flow Task 并关联到 Execute SQL Task，点击连接线设置条件控制。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702408137973.png"/></p><p>DFT_TEST_AFTER_MAX 上的连接线条件判断为：DATEDIFF( "dd", (DT_DBDATE) (@[User::TEST_DATE]) , (DT_DBDATE) (@[User::MAX_DATE])) &gt;=0</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702486888868.png"/></p><p>DFT_TEST_BEFORE_MAX上的判断表达式为：DATEDIFF( "dd", (DT_DBDATE) (@[User::TEST_DATE]) , (DT_DBDATE) (@[User::MAX_DATE])) &lt;0</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041702588134875.png"/></p><p>左右两个数据流下各加入一个 Script Task 显示一下这几个变量的值，代码如下:</p><pre><code><span style="color: rgb(0, 0, 255);">public</span> <span style="color: rgb(0, 0, 255);">void</span><span style="color: rgb(0, 0, 0);"> Main()<br/>
  {<br/>
   </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> TODO: Add your code here<br/>
            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);">User::EXISTING_COUNT,User::MAX_DATE,User::TEST_DATE</span><br/>
            <span style="color: rgb(0, 0, 255);">string</span> existing_count = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::EXISTING_COUNT</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
            </span><span style="color: rgb(0, 0, 255);">string</span> max_date = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::MAX_DATE</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
            </span><span style="color: rgb(0, 0, 255);">string</span> test_date = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::TEST_DATE</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
<br/>
            MessageBox.Show(</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">Existing Count - </span><span style="color: rgb(128, 0, 0);">"</span> + existing_count + <span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">, test date - </span><span style="color: rgb(128, 0, 0);">"</span> + test_date + <span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">, max date - </span><span style="color: rgb(128, 0, 0);">"</span> +<span style="color: rgb(0, 0, 0);"> max_date);<br/>
   Dts.TaskResult </span>= (<span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">)ScriptResults.Success;<br/>
  }</span></code></pre><p>保存并执行包，流程走了右边，因为 MAX DATE 要比 TEST DATE 大。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041704288285907.png"/></p><p>修改 TEST_DATE，那么 TEST DATE 要比 MAX DATE 大。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041705170008356.png"/></p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041705280634678.png"/></p><p>这就是 Execute SQL Task 中 Single Row 的使用方法。</p><h2 id="articleHeader4">FULL Result Set</h2><p>通常在 Execute SQL Task 中使用到 FULL Result Set 就一定会结合 Foreach Loop 来使用，所适用的场景是循环便利查询结果集中的每一行数据，将每一行的数据其中某几列取出来放入到变量中，然后同样在 Foreach Loop 中的其它控制流控件使用这些变量做一些操作。</p><h3 id="articleHeader5">疑问</h3><p>像这种遍历为什么不放到数据库中直接遍历不是更好吗？问题就在于，有时操作的对象并不仅仅是数据库中的表对象，而是涉及到不同的文件处理，这时就需要使用这种方式了。比如，我的目标数据源中有几百个文件，且文件的命名包括产品的名称，现在表中有产品名称的记录。需要循环遍历表中的产品，并对比哪些文件命名包含有这些产品名称，包含产品名称的文件则抽取数据，不包含产品名称的文件则移到其它目录。</p><p>下面使用这个查询作为一个示例结果集 -</p><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201409/041706139857313.png"/></p><p>使用 FULL RESULT SET  </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041706240781564.png"/></p><p>定义如下几个变量 - ORDER_SET 用来保存 Execute SQL Task 查询中的结果集，其它变量用来在循环每一行的时候保存每一列的值。注意：返回的结果集要使用 OBJECT 类型的变量来保存，这个 OBJECT 类型在内部以集合的形式存在并保存整个查询结果集。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041706347667699.png"/></p><p>EXECUTE SQL TASK 的 Mapping。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041706476103275.png"/></p><h3 id="articleHeader6">Foreach 下的设置</h3><p>我们可以通过 Foreach 的方式循环遍历这个返回的集合。添加一个 Foreach 控件，并设置遍历方式 - Foreach ADO Enumerator 和要遍历的集合对象。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041709308602668.png"/></p><p>遍历这个集合的时候，每次返回一行，这一行也是一个集合，通过设置索引0,1,2 将这个集合的元素赋值给各个变量。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041709488752798.png"/></p><p>在 Foreach 控件中添加一个 Script Task 用来显示每一行中各列的内容。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041710003915047.png"/></p><p>Script 中的脚本代码如下：</p><pre><code><span style="color: rgb(0, 0, 255);">public</span> <span style="color: rgb(0, 0, 255);">void</span><span style="color: rgb(0, 0, 0);"> Main()<br/>
  {<br/>
   </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> TODO: Add your code here<br/>
            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);">User::PRODUCT_ID,User::SALES_ORDER_DETAIL_ID,User::UNIT_PRICE</span><br/>
            <span style="color: rgb(0, 0, 255);">string</span> detailID = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::SALES_ORDER_DETAIL_ID</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
            </span><span style="color: rgb(0, 0, 255);">string</span> productID = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::PRODUCT_ID</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
            </span><span style="color: rgb(0, 0, 255);">string</span> unitPrice = Dts.Variables[<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::UNIT_PRICE</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value.ToString();<br/>
<br/>
            MessageBox.Show(</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">Detail ID - </span><span style="color: rgb(128, 0, 0);">"</span> + detailID+<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">, Product ID - </span><span style="color: rgb(128, 0, 0);">"</span>+productID +<span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">, Unite Price - </span><span style="color: rgb(128, 0, 0);">"</span>+<span style="color: rgb(0, 0, 0);"> unitPrice);<br/>
   Dts.TaskResult </span>= (<span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">)ScriptResults.Success;<br/>
  }</span></code></pre><p>保存并执行包，第一次循环的结果是失败的，但是可以看出来我们的结果集返回是没有问题的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041710380167318.png"/></p><p>出错的原因如下：</p><p><span style="color: rgb(255, 0, 0);">Error: The type of the value (String) being assigned to variable "User::SALES_ORDER_DETAIL_ID" differs from the current variable type (Int32). Variables may not change type during execution. Variable types are strict, except for variables of type Object.</span></p><p><span style="color: rgb(255, 0, 0);">Error: The type of the value (String) being assigned to variable "User::PRODUCT_ID" differs from the current variable type (Int32). Variables may not change type during execution. Variable types are strict, except for variables of type Object.</span></p><p><span style="color: rgb(255, 0, 0);">Error: The type of the value (String) being assigned to variable "User::UNIT_PRICE" differs from the current variable type (Decimal). Variables may not change type during execution. Variable types are strict, except for variables of type Object.</span></p><p><span style="color: rgb(255, 0, 0);"><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041711186724831.png"/></span></p><p>这是由于<span style="color: rgb(255, 0, 0);">在集合中的数据默认都是 String 类型的，是不能够直接转换成我们定义的变量所指定的类型</span>，因此需要修改我们的变量类型。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041711308603007.png"/></p><p>再次执行就可以看到遍历的效果，第一次 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041712196571100.png"/></p><p>最后一次 - </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041712327661062.png"/></p><h2 id="articleHeader7">Script Task 中的循环遍历</h2><p>同样的 Object 对象，不仅仅可以在 Foreach 中循环遍历，也可以直接在 Script Task 中循环遍历。</p><p>添加一个 Script Task，把结果集对象放入变量列表中。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041713021571782.png"/></p><p>脚本代码如下 - </p><pre><code><span style="color: rgb(0, 0, 255);">using</span><span style="color: rgb(0, 0, 0);"> System.Data.OleDb;<br/>
<br/>
</span><span style="color: rgb(0, 0, 255);">public</span> <span style="color: rgb(0, 0, 255);">void</span><span style="color: rgb(0, 0, 0);"> Main()<br/>
  {<br/>
   </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> TODO: Add your code here </span><br/>
            OleDbDataAdapter adapter = <span style="color: rgb(0, 0, 255);">new</span><span style="color: rgb(0, 0, 0);"> OleDbDataAdapter();<br/>
            DataTable dataTable </span>= <span style="color: rgb(0, 0, 255);">new</span><span style="color: rgb(0, 0, 0);"> DataTable(); <br/>
<br/>
            adapter.Fill(dataTable, Dts.Variables[</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">User::ORDER_SET</span><span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(0, 0, 0);">].Value);<br/>
<br/>
            </span><span style="color: rgb(0, 0, 255);">foreach</span> (DataRow row <span style="color: rgb(0, 0, 255);">in</span><span style="color: rgb(0, 0, 0);"> dataTable.Rows)<br/>
            {<br/>
                MessageBox.Show(row[</span><span style="color: rgb(128, 0, 128);">0</span>] + <span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">,</span><span style="color: rgb(128, 0, 0);">"</span> + row[<span style="color: rgb(128, 0, 128);">1</span>] + <span style="color: rgb(128, 0, 0);">"</span><span style="color: rgb(128, 0, 0);">,</span><span style="color: rgb(128, 0, 0);">"</span> + row[<span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);">]); <br/>
            } <br/>
<br/>
   Dts.TaskResult </span>= (<span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);">)ScriptResults.Success;<br/>
  }</span></code></pre><p>一样可以实现遍历的效果 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041713352978057.png"/></p><p>最后一条记录-</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201409/041713472359776.png"/></p><h2 id="articleHeader8">总结</h2><p>通过讲解 Execute SQL Task 的两种查询结果返回方式 Single Row 和 Full Result Set，实际上由此引申出了何时使用 Single Row 以及 Full Result Set 的场景。熟悉和掌握这些场景可以帮助我们在复杂的 ETL 项目中找出各种不同的解决方案，可以非常灵活的解决一些实际问题。</p><p>再次，特别通过 Foreach Loop Container 以及 Script Task 学习到了两种解析 Full Result Set 的方式，其中涉及到的知识点以及细节还是比较多的，特意总结下来希望可以帮助到大家。<br/></p>
</div>]
</body>
</html>
