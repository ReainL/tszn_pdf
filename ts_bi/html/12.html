
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h3 id="articleHeader1" style="margin-left: 0px;">开篇介绍 </h3><p style="margin-left: auto;">在之前的文章中我介绍到了 Lookup 查找转换控件中在 OLE DB 模式下 Lookup 的几种缓存模式： Full Cache 完全缓存，Partial Cache 部分缓存，No Cache 无缓存。这几种缓存模式可以满足我们的绝大部分需要，但是自 SQL Server 2008 R2 开始，SSIS 对 Lookup 的缓存模式做了加强，出现了另外的一种缓存模式 Cache Connection Manager 缓存连接管理器。它不仅支持数据流中的内存缓存共享，而且还支持文件缓存共享。通过内存缓存，缓存可以供多个数据流中的 Lookup 使用；通过文件缓存，缓存文件不仅可以供多个数据流使用，而且还可以供不同包中的 Lookup 控件来使用。</p><h3 id="articleHeader2" style="margin-left: 0px;">Cache Transform 缓存转换介绍</h3><p style="margin-left: auto;">Cache Transform 缓存转换控件是从 2008 就开始有了的，它可以通过配置将数据缓存起来再到 Lookup 查找转换控件中使用。使用这种缓存在效率上会比从数据库中加载数据再缓存对比的过程要更高一些，因为这种缓存是可以反复使用的。另外的一种情况就是，这种缓存还可以持久化写入到本地的文件中，那么就可以在多个包中以及不同 Lookup 中来重复使用缓存文件。特别是多个 Lookup 任务，或者多个包都有相同的 Lookup 引用集需求的时候，使用文件缓存可以避免反复的查询数据库。并且还有一定非常重要，就是在 OLE DB 模式下的 Full Cache 完全缓存对内存是有要求的，即缓存的内容不能超过内存的容量，但是这里的文件缓存则是写入到磁盘上，可以最大程度上避免这种问题。</p><p style="margin-left: auto;">示例如下：</p><p style="margin-left: auto;">在数据库中有一张有关订单的 Mapping 表，我们要 Lookup 的就是这张表的内容，首先需要将它查询并缓存到缓存内存或者缓存文件中去。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101804282108310.png"/></p><p style="margin-left: auto;">这张表先通过 OLE_SRC_ORDERS 查询出来，将查询的结果交给缓存转换 Cache Transform - CT_ORDERS。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101804367258075.png"/></p><p style="margin-left: auto;">编辑 CT_ORDERS 第一次是需要创建一个缓存连接管理器的。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101804466477909.png"/></p><p style="margin-left: auto;">在缓存连接管理器中，有两种关于缓存的存放方式，默认情况下存放在内存中，这里选用文件缓存，那么不同包都可以使用同一个缓存文件。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101804538037891.png"/></p><p style="margin-left: auto;">由于在后面的 Lookup 中需要比较的列有两列 SalesOrderNumber 和 SalesOrderLineNumber，因此这里的索引依次按 1,2 序号递增；非 Lookup 列，但是需要匹配输出的列给索引序号 0。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805011009129.png"/></p><p style="margin-left: auto;">回到 Cache 转换控件，可以看到来自于 OLE DB Source 中的三个输入列是如何和缓存配置中的列匹配的。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805080533938.png"/></p><p style="margin-left: auto;">注意：如果要使用缓存，那么缓存必须存在于所有引用缓存的 Lookup 控件所在的数据流任务之前，或缓存所在的包必须存在于所有引用缓存的 Lookup 控件所在的包之前。</p><p style="margin-left: auto;">第一个含有 Lookup 数据流的任务中，输入数据源来自一个文件，包含有 SalesOrderNumber 和 SalesOrderLineNumber 以及 SalesAmount 等所有订单信息。它需要在缓存中查找对应的 SalesOrderNumber 和 SalesLineNumber 是否存在，如果存在则将对应的文件中的数据输出到一个表中。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805158977373.png"/></p><p style="margin-left: auto;">这里只有匹配输出，不匹配的不用处理(并非真正不用处理，而是重定向的数据没有输出目标来接收)。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805255696452.png"/></p><p style="margin-left: auto;">Lookup 控件 LKP_ORDER_LINES 中的配置，在这里如果选择了 Partial Cache 或者 No Cache 那么就只能是 OLE DB Connection Manager，即如果选择 Cache Connection Manager 是没有 Partial Cache 和 No Cache 这种概念和配置的。不匹配时数据流重定向到不匹配输出 Output，尽管后面没有处理，这也是可以的。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805434282098.png"/></p><p style="margin-left: auto;">此时的 Connection 连接就不是之前 OLE DB Connection 中的引用数据集，通过视图，表或者查询语句来配置的了，这里就是缓存。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805514751706.png"/></p><p style="margin-left: auto;">在查找列种，右侧的两个放大镜就是之前在配置缓存的时候一样的效果，文件数据源根据缓存中的 SalesOrderNumber，SalesOrderLineNumber 来匹配查找 SEQ_ID，如果找到就是匹配输出，输出列包括左侧文件源中的 Available Input Columns 所有列和 Available Lookup Columns 中被选中的列 SEQ_ID；如果没有找到，就是不匹配输出，输出列就只有左侧的 Available Input Columns 中的所有列。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101805585696770.png"/></p><p style="margin-left: auto;">在我的测试案例中，DFT_LOAD_ORDERS_1 和 DFT_LOAD_ORDERS_2 以及 EPT_LOOKUP_CACHE_3 中的 Lookup 除了输出的表不一样以外，其它配置都完全一致。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101806064601894.png"/></p><p style="margin-left: auto;">利用文件缓存，在一个包中的几个数据流 ( DFT_LOAD_ORDERS_1, DFT_LOAD_ORDERS_2 ) 中的 Lookup 都可以使用到，并且在其它的包 ( EPT_LOOKUP_CACHE_3 ) 也一样可以使用的到。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101806154753574.png"/></p><p style="margin-left: auto;">打开缓存连接管理器，将使用文件缓存的勾去掉，并且删除掉文件缓存的文件。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101806255855351.png"/></p><p style="margin-left: auto;">这时数据是在缓存当前包运行时的内存中的，在这个包中的位于缓存转换执行之后的所有数据流中的 Lookup 查找转换都可以访问的到，但是不同的包就无法访问了。</p><p style="margin-left: auto;"><img alt="" src="http://images.cnitblog.com/blog/477275/201411/101806360859543.png"/></p><h3 id="articleHeader3" style="margin-left: 0px;">跟这篇文章相关的文章还有</h3><ul><li><a href="http://www.cnblogs.com/biwork/p/3296602.html">微软BI 之SSIS 系列 - Lookup 组件的使用与它的几种缓存模式 - Full Cache, Partial Cache, NO Cache</a> </li><li><a href="http://www.cnblogs.com/biwork/p/3921802.html">微软BI 之SSIS 系列 - Lookup 中的字符串比较大小写处理 Case Sensitive or Insensitive</a></li></ul>
<ul class="aw-upload-file-list">
</ul>
</div>]
</body>
</html>
