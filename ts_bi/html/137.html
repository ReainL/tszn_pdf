
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>这一章主要是介绍 窗体中的 Aggregate 函数、Rank 函数、Distribution 函数以及 Offset 函数。</p><h2 id="articleHeader2">Window Aggregate 函数</h2><p>Window Aggregate 函数和在Group分组中使用的聚合函数是一样的, 只是不再定义Group并且是通过 OVER子句来定义和使用的。在标准的SQL中，窗体聚合函数是支持这三种元素的 - Partitioning、Ordering 和 Framing。</p><pre><code><span><span style='font-family: "Microsoft Yahei";'>function_name(<span style="color: rgb(128, 128, 128);">&lt;</span>arguments<span style="color: rgb(128, 128, 128);">&gt;</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);"> &lt;window partition clause&gt; </span><span style="color: rgb(255, 0, 0);">]</span><br/>
<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);"> &lt;window order clause&gt; [ &lt;window frame clause&gt; </span><span style="color: rgb(255, 0, 0);">]</span> ] )</span></span></code></pre><p>这三种元素的作用可以限制窗体集中的行，如果没有指定任何元素，那么窗体中包含的就是查询结果集中所有的行。</p><h3 id="articleHeader3">Partitioning 分区</h3><p>通过PARTITION BY 得到的窗体集是基于当前查询结果的当前行的一个集,，比如说 PARTITION BY CustomerID，当前行的 CustomerID = 1，那么对于当前行的这个 Window 集就是在当前查询结果之上再加上 CustomerID = 1 的一个查询结果。如果当前行的 CustomerID = 2，那么它的窗体就是在查询结果上所有 CustomerID = 2 的集。</p><p>与GROUP不同，PARTITION 可以在一个 SELECT 中对应不同的分区列，并且每一行对应的窗体集也可能而不相同。</p><p>与子查询也不同，子查询可以任意查询不同的对象集，而 PARTITION 分区对应的窗口集首先它是基于当前 SELECT 的结果集。</p><p>回顾上一篇文章中提到的这个例子 -</p><pre><code><span><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">USE</span> TSQL2012;<br/>
<span style="color: rgb(0, 0, 255);">GO</span><br/>
<br/>
<span style="color: rgb(0, 0, 255);">SELECT</span> orderid,<br/>
            custid,<br/>
            val,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(val) <span style="color: rgb(0, 0, 255);">OVER</span>() <span style="color: rgb(0, 0, 255);">AS</span> sumall,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(val) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> custid) <span style="color: rgb(0, 0, 255);">AS</span> sumcust<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.OrderValues <span style="color: rgb(0, 0, 255);">AS</span> O1;<br/>
 </span></span></code></pre><p>-- 查询结果</p><p>10643        1        814.50        1265793.22        4273.00</p><p>10692        1        878.00        1265793.22        4273.00</p><p>10702        1        330.00        1265793.22        4273.00</p><p>10835        1        845.80        1265793.22        4273.00</p><p>10952        1        471.20        1265793.22        4273.00</p><p>11011        1        933.50        1265793.22        4273.00</p><p>10926        2        514.40        1265793.22        1402.95</p><p>10759        2        320.00        1265793.22        1402.95</p><p>10625        2        479.75        1265793.22        1402.95</p><p> </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201308/07213752-01e0a2c0733046239fa8131dcb1db2e7.png"/></p><p>第一个窗体函数每一行对应的都是相同的，它们的窗体都一样，计算的都是Val的总和。</p><p>第二个窗体函数每一行对应的可能是不同的，因为它基于 custid 进行了分区，即在所有的窗体集基础上加入了 custid = 当前行的 custid 这个过滤限制。</p><pre><code><span><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span> orderid,<br/>
            custid,<br/>
            val,<br/>
            <span style="color: rgb(255, 0, 255);">CAST</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">100</span>. <span style="color: rgb(128, 128, 128);">*</span> val <span style="color: rgb(128, 128, 128);">/</span> <span style="color: rgb(255, 0, 255);">SUM</span>(val) <span style="color: rgb(0, 0, 255);">OVER</span>() <span style="color: rgb(0, 0, 255);">AS</span> NUMERIC(<span style="color: rgb(128, 0, 0); font-weight: bold;">5</span>, <span style="color: rgb(128, 0, 0); font-weight: bold;">2</span>)) <span style="color: rgb(0, 0, 255);">AS</span> pctall,<br/>
            <span style="color: rgb(255, 0, 255);">CAST</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">100</span>. <span style="color: rgb(128, 128, 128);">*</span> val <span style="color: rgb(128, 128, 128);">/</span> <span style="color: rgb(255, 0, 255);">SUM</span>(val) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> custid) <span style="color: rgb(0, 0, 255);">AS</span> NUMERIC(<span style="color: rgb(128, 0, 0); font-weight: bold;">5</span>, <span style="color: rgb(128, 0, 0); font-weight: bold;">2</span>)) <span style="color: rgb(0, 0, 255);">AS</span> pctcust<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.OrderValues <span style="color: rgb(0, 0, 255);">AS</span> O1;<br/>
 </span></span></code></pre><p>-- 查询结果</p><p>10643        1        814.50        0.06        19.06</p><p>10692        1        878.00        0.07        20.55</p><p>10702        1        330.00        0.03        7.72</p><p>10835        1        845.80        0.07        19.79</p><p>10952        1        471.20        0.04        11.03</p><p>11011        1        933.50        0.07        21.85</p><p>10926        2        514.40        0.04        36.67</p><p>10759        2        320.00        0.03        22.81</p><p>10625        2        479.75        0.04        34.20</p><p> </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201308/07213836-80681206f1e945f29d48c7d10596d527.png"/></p><p>这几个窗体同时并存。</p><h3 id="articleHeader4">Ordering and Framing</h3><p>Framing 框架也是用来过滤和限制窗体集中的行，但同时一般会首先排好序，然后再通过 Framing 来定位窗体集中的起始行和结束行来获取特定的行集。</p><pre><code><span><span style='font-family: "Microsoft Yahei";'>function_name(<span style="color: rgb(128, 128, 128);">&lt;</span>arguments<span style="color: rgb(128, 128, 128);">&gt;</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);"> &lt;window partition clause&gt; </span><span style="color: rgb(255, 0, 0);">]</span><br/>
<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);"> &lt;window order clause&gt; [ &lt;window frame clause&gt; </span><span style="color: rgb(255, 0, 0);">]</span> ] )</span></span></code></pre><p>在 &lt;window frame clause&gt; 中, 有这三个部分 - &lt;window frame units&gt; &lt;window frame extent&gt; [ &lt;window frame exclusion&gt; ]。</p><p>在 &lt;window frame units&gt; 应该指定 ROWS 或者 RANGE。</p><h3 id="articleHeader5">ROWS 的使用</h3><pre><code><span><span style='font-family: "Microsoft Yahei";'>ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
                   <span style="color: rgb(128, 128, 128);">&lt;</span>n<span style="color: rgb(128, 128, 128);">&gt;</span> PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
                   <span style="color: rgb(128, 128, 128);">&lt;</span>n<span style="color: rgb(128, 128, 128);">&gt;</span> FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
             <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW<br/>
<span style="color: rgb(128, 128, 128);">AND</span><br/>
             UNBOUNDED FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
                   <span style="color: rgb(128, 128, 128);">&lt;</span>n<span style="color: rgb(128, 128, 128);">&gt;</span> PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
                   <span style="color: rgb(128, 128, 128);">&lt;</span>n<span style="color: rgb(128, 128, 128);">&gt;</span> FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
             <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW</span></span></code></pre><ul><li>UNBOUNDED PRECEDING 指的是相对于当前行来说之前的所有的行</li><li>UNBOUNDED FOLLOWING 指的是相对于当前行来说之后的所有的行</li><li>CURRENT ROW 就是当前行</li></ul><pre><code><span><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
            ordermonth,<br/>
            qty,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
                                     PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING<br/>
                                     <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW<br/>
                                 ) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></span></code></pre><p>-- 查询结果</p><p>1        2006-07-01 00:00:00.000        121        121</p><p>1        2006-08-01 00:00:00.000        247        368</p><p>1        2006-09-01 00:00:00.000        255        623</p><p>1        2006-10-01 00:00:00.000        143        766</p><p>1        2006-11-01 00:00:00.000        318        1084</p><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201308/07214104-bbf609bb5c144e63b4a30fe032787f03.png"/></p><p> </p><p>可以写的更简洁一些。</p><pre><code><span><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
            ordermonth,<br/>
            qty,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
                                      PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                      <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                      ROWS UNBOUNDED PRECEDING<br/>
                                  ) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></span></code></pre><p>下面的这个例子定义了3个窗体：</p><ul><li>第一个窗体中 ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING 所表明的行的范围就是当前行的上一行。</li><li>第二个窗体中 ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING 所表明的行的范围是当前行的下一行。</li><li>第三个窗体中 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING 所表明的行的范围是上一行到一下行。</li></ul><pre><code><span><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
       ordermonth,<br/>
       <span style="color: rgb(255, 0, 255);">MAX</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
                                     PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> PRECEDING<br/>
　　　　　　　　　　　　) <span style="color: rgb(0, 0, 255);">AS</span> prvqty,<br/>
   　　qty <span style="color: rgb(0, 0, 255);">AS</span> curqty,<br/>
   　　<span style="color: rgb(255, 0, 255);">MAX</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
                                     PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> FOLLOWING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> FOLLOWING<br/>
　　　　) <span style="color: rgb(0, 0, 255);">AS</span> nxtqty,<br/>
  　　 <span style="color: rgb(255, 0, 255);">AVG</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(<br/>
                                     PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">1</span> FOLLOWING<br/>
) <span style="color: rgb(0, 0, 255);">AS</span> avgqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></span></code></pre><p>-- 查询结果</p><p>1        2006-07-01 00:00:00.000        NULL      121        247        184</p><p>1        2006-08-01 00:00:00.000        121         247        255        207</p><p>1        2006-09-01 00:00:00.000        247         255        143        215</p><p>1        2006-10-01 00:00:00.000        255         143        318        238</p><p>1        2006-11-01 00:00:00.000        143         318        536        332</p><p>1        2006-12-01 00:00:00.000        318         536        304        386</p><p>1        2007-01-01 00:00:00.000        536         304        168        336</p><p>1        2007-02-01 00:00:00.000        304         168        275        249</p><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201308/07214204-32e319cb70c3432b8e759c60e4de50d1.png"/></p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201308/07214219-3e1bbf33e3964cae973fd7378a04c731.png"/></p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201308/07214231-c65fe8c2c811431ea7baef796ef32d1e.png"/></p><p>需要值得注意的是, 第三个窗体中求平均值的时候，第一行没有上一行元素的引用，最后一行也不会存在对下一行的引用，所以对于第一行和最后一行的窗体行数可能比其它的窗体行数相对要少，但是最多不会超过3行，AVG 函数在这里会自动判断行数来求平均值。</p><p>在这个例子中，PARTITION的列和 ORDER 列它们组合在一起唯一标识了一行记录，因此它们在窗体集里不会重复，所以它们查询出来的结果是唯一的。</p><p>当使用在 PARTITION 和 ORDER 上的列组合起来不能唯一确定一行记录的话，查询的结果有可能不是唯一的，下面的例子就能说明这个问题。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SET</span> NOCOUNT <span style="color: rgb(0, 0, 255);">ON</span>;<br/>
<span style="color: rgb(0, 0, 255);">USE</span> TSQL2012;<br/>
<br/>
<span style="color: rgb(0, 0, 255);">IF</span> <span style="color: rgb(255, 0, 255);">OBJECT_ID</span>(<span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">dbo.T1</span><span style="color: rgb(255, 0, 0);">'</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">U</span><span style="color: rgb(255, 0, 0);">'</span>) <span style="color: rgb(0, 0, 255);">IS</span> <span style="color: rgb(128, 128, 128);">NOT</span> <span style="color: rgb(0, 0, 255);">NULL</span> <span style="color: rgb(0, 0, 255);">DROP</span> <span style="color: rgb(0, 0, 255);">TABLE</span> dbo.T1;<br/>
<span style="color: rgb(0, 0, 255);">GO</span><br/>
<br/>
<span style="color: rgb(0, 0, 255);">CREATE</span> <span style="color: rgb(0, 0, 255);">TABLE</span> dbo.T1<br/>
(<br/>
    keycol <span style="color: rgb(0, 0, 255);">INT</span> <span style="color: rgb(128, 128, 128);">NOT</span> <span style="color: rgb(0, 0, 255);">NULL</span> <span style="color: rgb(0, 0, 255);">CONSTRAINT</span> PK_T1 <span style="color: rgb(0, 0, 255);">PRIMARY</span> <span style="color: rgb(0, 0, 255);">KEY</span>,<br/>
    col1 <span style="color: rgb(0, 0, 255);">VARCHAR</span>(<span style="color: rgb(128, 0, 0); font-weight: bold;">10</span>) <span style="color: rgb(128, 128, 128);">NOT</span> <span style="color: rgb(0, 0, 255);">NULL</span><br/>
);<br/>
<br/>
<span style="color: rgb(0, 0, 255);">INSERT</span> <span style="color: rgb(0, 0, 255);">INTO</span> dbo.T1 <span style="color: rgb(0, 0, 255);">VALUES</span><br/>
(<span style="color: rgb(128, 0, 0); font-weight: bold;">2</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">A</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">3</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">A</span><span style="color: rgb(255, 0, 0);">'</span>),<br/>
(<span style="color: rgb(128, 0, 0); font-weight: bold;">5</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">B</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">7</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">B</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">11</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">B</span><span style="color: rgb(255, 0, 0);">'</span>),<br/>
(<span style="color: rgb(128, 0, 0); font-weight: bold;">13</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">C</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">17</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">C</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">19</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">C</span><span style="color: rgb(255, 0, 0);">'</span>),(<span style="color: rgb(128, 0, 0); font-weight: bold;">23</span>, <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">C</span><span style="color: rgb(255, 0, 0);">'</span>);<br/>
<br/>
<span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(128, 128, 128);">*</span> <span style="color: rgb(0, 0, 255);">FROM</span> dbo.T1</span></code></pre><p>查询结果</p><p>2        A</p><p>3        A</p><p>5        B</p><p>7        B</p><p>11        B</p><p>13        C</p><p>17        C</p><p>19        C</p><p>23        C</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> keycol, <br/>
       col1,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> col1<br/>
                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> cnt<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> dbo.T1</span></code></pre><p>查询结果</p><p>2        A        1</p><p>3        A        2</p><p>5        B        3</p><p>7        B        4</p><p>11        B        5</p><p>13        C        6</p><p>17        C        7</p><p>19        C        8</p><p>23        C        9</p><p>由于没有使用 PARTITION，因此默认的情况就是每一行都使用的相同的 PARTITION 即 SELECT 查询结果集。但是在这里由于ORDER BY 的列 col1 并不是唯一的，因此相同的 col1 的行共享同一个窗体，那么这时它们计算 COUNT 的方式可能就无法确定。</p><p>比如这个例子中的 A、B、C， A 对应的窗体里有2条A 的记录，B 有3条，C 有4条，无法判断它们如何定位计算。这时 SQL Server就强制性的给相同的元素定了位以便计算各个元素之前的条数。</p><p>给它们设置一个唯一索引，这样SQL Server就知道如何在内部对它们进行排序。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">CREATE</span> <span style="color: rgb(0, 0, 255);">UNIQUE</span> <span style="color: rgb(0, 0, 255);">INDEX</span> idx_col1D_keycol <span style="color: rgb(0, 0, 255);">ON</span> dbo.T1(col1 <span style="color: rgb(0, 0, 255);">DESC</span>, keycol);<br/>
<br/>
<span style="color: rgb(0, 0, 255);">SELECT</span> keycol, <br/>
       col1,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> col1<br/>
                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> cnt<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> dbo.T1</span></code></pre><p>查询结果</p><p>3          A        1</p><p>2          A        2</p><p>11        B        3</p><p>7          B        4</p><p>5          B        5</p><p>23        C        6</p><p>19        C        7</p><p>17        C        8</p><p>13        C        9</p><p>理解了这个原因之后，可以这样写来确保在窗体集里的排序的元素是唯一的，这样查询的结果也一定是唯一的。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> keycol, <br/>
       col1,<br/>
       <span style="color: rgb(255, 0, 255);">COUNT</span>(<span style="color: rgb(128, 128, 128);">*</span>) <span style="color: rgb(0, 0, 255);">OVER</span>(<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> keycol,col1<br/>
                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> cnt<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> dbo.T1</span></code></pre><p>2        A        1</p><p>3        A        2</p><p>5        B        3</p><p>7        B        4</p><p>11        B        5</p><p>13        C        6</p><p>17        C        7</p><p>19        C        8</p><p>23        C        9</p><h3 id="articleHeader6">RANGE 框架的扩展选项和使用</h3><p>定义</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'>RANGE <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(128, 128, 128);">&lt;</span>val<span style="color: rgb(128, 128, 128);">&gt;</span> PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(128, 128, 128);">&lt;</span>val<span style="color: rgb(128, 128, 128);">&gt;</span> FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(0, 0, 255);">CURRENT</span> ROW<br/>
<span style="color: rgb(128, 128, 128);">AND</span><br/>
UNBOUNDED FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(128, 128, 128);">&lt;</span>val<span style="color: rgb(128, 128, 128);">&gt;</span> PRECEDING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(128, 128, 128);">&lt;</span>val<span style="color: rgb(128, 128, 128);">&gt;</span> FOLLOWING <span style="color: rgb(128, 128, 128);">|</span><br/>
<span style="color: rgb(0, 0, 255);">CURRENT</span> ROW</span></code></pre><p>要事先说的是 RANGE 框架在 SQL Server 2012 中并没有实现的很完善, 目前只支持 UNBOUNDED 和  CURRENT ROW 这两个选项。</p><p>比如说，这样的代码</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
       ordermonth,<br/>
       qty,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                     RANGE <span style="color: rgb(128, 128, 128);">BETWEEN</span> <span style="color: rgb(128, 0, 0); font-weight: bold;">2</span> PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW)<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders <span style="color: rgb(0, 0, 255);">AS</span> O1<br/>
<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> empid,<br/>
       ordermonth</span></code></pre><p>会出现错误</p><p><span style="color: rgb(255, 0, 0);">Msg 4194, Level 16, State 1, Line 1</span></p><p><span style="color: rgb(255, 0, 0);">RANGE is only supported with UNBOUNDED and CURRENT ROW window frame delimiters.</span></p><p>如果假设有这样的一个代码结构能在 2012 中实现的话，那么就真正可以做到一个动态的范围控制。比如，查询当前月到它前两个月的订单总额。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,         ordermonth,         qty,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                     RANGE <span style="color: rgb(128, 128, 128);">BETWEEN</span> INTERVAL <span style="color: rgb(255, 0, 0);">'</span><span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(255, 0, 0);">'</span> <span style="color: rgb(255, 0, 255);">MONTH</span> PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> sum3month<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><p>假设，当前月是3月，那么它前两个月就应该包含2月和1月，那么总共的取值范围就是1，2，3 这三个月。假设2月份没有数据时，那么结果就应该是1月和3月，而不会因为2月不存在就往前走一个月包含12，1和3月来凑齐3个月，这就是 RANGE 和 ROWS 的不同 。只不过很遗憾，目前还没有支持到这个程度。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201308/22223533-db7091e803f242978aa52c3ef476dca9.png"/></p><p>如何理解和 ROWS 不同，ROWS BETWEEN 2 PRECEDING AND CURRENT ROW 表示的是包含当前行以及前两行的数据。借用上面的一个例子，如果当前月是3月，同时2月份的数据不存在，那么它取值的范围是 12月，1月和3月。</p><p>现在如果想要实现类似于RANGE BETWEEN INTERVAL '2' MONTH PRECEDING 的效果在 Windows Function 中还是非常复杂， 还有一个选择就是使用下面提到的</p><p>这种替代方案。</p><p>查询员工在各个订单月的订单额以及从当前月到它前两个月共三个月的总订单额。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
       ordermonth,<br/>
       qty,<br/>
         (    <span style="color: rgb(0, 0, 255);">SELECT</span> <span style="color: rgb(255, 0, 255);">SUM</span>(qty)<br/>
              <span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders <span style="color: rgb(0, 0, 255);">AS</span> O2<br/>
              <span style="color: rgb(0, 0, 255);">WHERE</span> O2.empid <span style="color: rgb(128, 128, 128);">=</span> O1.empid<br/>
              <span style="color: rgb(128, 128, 128);">AND</span> O2.ordermonth <span style="color: rgb(128, 128, 128);">BETWEEN</span> <span style="color: rgb(255, 0, 255);">DATEADD</span>(<span style="color: rgb(255, 0, 255);">MONTH</span>, <span style="color: rgb(128, 128, 128);">-</span><span style="color: rgb(128, 0, 0); font-weight: bold;">2</span>, O1.ordermonth)<br/>
              <span style="color: rgb(128, 128, 128);">AND</span> O1.ordermonth<br/>
        ) <span style="color: rgb(0, 0, 255);">AS</span> sum3month<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders <span style="color: rgb(0, 0, 255);">AS</span> O1<br/>
<span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> empid,<br/>
         ordermonth</span></code></pre><p>查询结果</p><p>1        2006-07-01 00:00:00.000        121        121</p><p>1        2006-08-01 00:00:00.000        247        368</p><p>1        2006-09-01 00:00:00.000        255        623</p><p>1        2006-10-01 00:00:00.000        143        645</p><p>1        2006-11-01 00:00:00.000        318        716</p><p>通过上面这种方式来查询就实现了 RANGE BETWEEN INTERVAL '2' MONTH PRECEDING  所描述的效果。</p><p>如果只是计算包含当前月以及之前所有月份的总和，在这里使用 RANGE 和 ROWS 效果一样。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
            ordermonth,<br/>
            qty,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                                    <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                                    RANGE <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
       ordermonth,<br/>
       qty,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                     <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                     ROWS <span style="color: rgb(128, 128, 128);">BETWEEN</span> UNBOUNDED PRECEDING <span style="color: rgb(128, 128, 128);">AND</span> <span style="color: rgb(0, 0, 255);">CURRENT</span> ROW) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><p>可以省略掉 CURRENT ROW， 默认就是</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
            ordermonth,<br/>
            qty,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                          <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth<br/>
                          RANGE UNBOUNDED PRECEDING ) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><p>甚至在这里可以更加简化成</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);">SELECT</span> empid,<br/>
            ordermonth,<br/>
            qty,<br/>
            <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid<br/>
                          <span style="color: rgb(0, 0, 255);">ORDER</span> <span style="color: rgb(0, 0, 255);">BY</span> ordermonth) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><p>因为这里使用了 PARTITION BY 和 ORDER BY 它们俩唯一定位了一条记录，虽然没有显示写出 RANGE UNBOUNDED PRECEDING 但是内部处理也是包含了从之前所有行当当前行的所有记录。</p><p>1        2006-07-01 00:00:00.000        121        121</p><p>1        2006-08-01 00:00:00.000        247        368</p><p>1        2006-09-01 00:00:00.000        255        623</p><p>1        2006-10-01 00:00:00.000        143        766</p><p>1        2006-11-01 00:00:00.000        318        1084</p><p>1        2006-12-01 00:00:00.000        536        1620</p><p>如果把 ORDER BY 去掉，那么就只剩下 empid，可以简单理解为按 empid 分类计算各个 empid 下的总和。</p><pre><code><span style='font-family: "Microsoft Yahei"; font-size: 13px;'><span style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);">S</span>ELECT</span> empid,         ordermonth,         qty,<br/>
       <span style="color: rgb(255, 0, 255);">SUM</span>(qty) <span style="color: rgb(0, 0, 255);">OVER</span>(PARTITION <span style="color: rgb(0, 0, 255);">BY</span> empid) <span style="color: rgb(0, 0, 255);">AS</span> runqty<br/>
<span style="color: rgb(0, 0, 255);">FROM</span> Sales.EmpOrders;</span></code></pre><p>查询结果</p><p>1        2007-03-01 00:00:00.000        275        7812</p><p>1        2008-01-01 00:00:00.000        397        7812</p><p>1        2007-12-01 00:00:00.000        583        7812</p><p>1        2006-11-01 00:00:00.000        318        7812</p><p>1        2008-03-01 00:00:00.000        467        7812</p><p>那么再来看看 RANGE 和 ROWS 到底有什么区别？</p><p>在之前提到的例子中，我们是假设 RANGE 支持 RANGE BETWEEN INTERVAL '2' MONTH PRECEDING  这样的功能来和 ROWS 做比较的。</p><p>而事实上我们知道，这个功能并没有在 SQL Server 2012 中实现。<br/></p>
</div>]
</body>
</html>
