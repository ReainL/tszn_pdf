
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>Precedence Constraint 优先约束 - 在控制流中使用，用来链接控制流中各种 Task，Container，并且要求满足一定的条件才能执行相关联的 Task 或者 Container。 比如下图中，第一个 Execute SQL Task 叫做 Precedence-Executable 优先可执行任务，而Script Task 由于在关联箭头的下游，所以它叫做 Constrained-Executable 受约束可执行任务。关联箭头的上游任务自然先执行，关联箭头下方的这种受约束可执行任务是否能够被执行则要取决于 Precedence Constraint 的配置了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052156301592419.png"/></p><p>EST_SELECT_VALUE 中的配置 - </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052157015815585.png"/></p><p>查询的结果赋值给一个字符串类型的变量，Script Task 就是显示一下这个变量的值而已。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052157110502679.png"/></p><p>双击绿色的线之后默认可以看到下面的这个配置，其中包括了约束与多约束的选项和配置。</p><ol><li>Evlaution Operation = Constraint  按上游 Task 执行结果决定是否执行下游 Script Task 任务（按执行结果约束）</li><li>Value = Success  上游任务 EST_SELECT_VALUE 执行成功后才执行下游 Script Task </li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052157190199813.png"/></p><p>EST_SELECT_VALUE 执行成功后自动执行 SCE_SHOW_RESULT</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052157446756718.png"/></p><h3 id="articleHeader2">Value = Failure上游任务 EST_SELECT_VALUE 执行失败后才执行下游 Script Task </h3><p>新建一个 SCR_SHOW_ERROR Script Task，里面不做任何操作。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052158221595702.png"/></p><p>修改 EST_SELECT_VALUE 与 SCR_SHOW_ERROR 之间的连接线，改成 Failure。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159043162449.png"/></p><p>将 EST_SELECT_VALUE 中的 SQL 语句改成 SELECT 1/0 AS A，这样会发生一个除数为零的错误，但是 SCR_SHOW_ERROR 是可以被执行到的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159180502545.png"/></p><h3 id="articleHeader3">Value = Complete 上游任务 EST_SELECT_VALUE 无论执行成功或者失败，只要执行完毕就执行下游 Script Task </h3><p>新建一个 Script Task - SCR_SHOW_COMPLETE，里面不做任何操作。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159329564398.png"/></p><p>修改连接线为 Complete。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159411599303.png"/></p><p>当 SQL 语句为 SELECT 1/0 AS A  EST_SELECT_VALUE 执行失败时，它被执行到了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159513626554.png"/></p><p>当 SQL 语句为 SELECT 1 AS A  EST_SELECT_VALUE 执行成功时，它也被执行到了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052159598009233.png"/></p><h3 id="articleHeader4">Evlaution Operation = Expression  按表达式约束，与上游任务执行成功与否的结果无关</h3><p>添加两个 Script Task - SCR_SHOW_EXP_EMPTY 和 SCR_SHOW_EXP_VALUE。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052200208948877.png"/></p><p>SCR_SHOW_EXP_EMPTY 的约束配置 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052200384565675.png"/></p><p>SCR_SHOW_EXP_VALUE 中的约束配置 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052200441288609.png"/></p><p>当 EST_SELECT_VALUE 中的 SQL 为 SELECT 1 AS A 时，PV_RESULT 的值为1，且 EST_SELECT_VALUE 执行成功！</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052200498471856.png"/></p><p>当 EST_SELECT_VALUE 中的 SQL 为 SELECT 1/0 AS A 时，PV_RESULT 的值不能从 EST_SELECT_VALUE 中正常接受，使用默认值 ""，且 EST_SELECT_VALUE 执行失败！</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052200567224790.png"/></p><p>可见 SCR_SHOW_RESULT，SCR_SHOW_ERROR，SCR_SHOW_COMPLETE 是否执行只与 EST_SELECT_VALUE 执行的结果有关( Success，Failure，Complete)，而与表达式无关。</p><p>而 SCR_SHOW_EXP_EMPTY 和 SCR_SHOW_EXP_VALUE 的执行只与表达式相关，而与 EST_SELECT_VALUE 的执行结果无关。</p><h2 id="articleHeader5">执行结果 AND 表达式 和 执行结果 OR 表达式</h2><p>新添加四个 Script Task</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201161913904.png"/></p><p>SCR_SHOW_SUCCESS_&amp;_EMPTY 中的配置要求 Expression 与 Constraint 同时成立。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201230036052.png"/></p><p>SCR_SHOW_SUCCESS_OR_EMPTY 中的配置要求 Expression 与 Constraint 有一个成立。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201282841998.png"/></p><p>SCR_SHOW_FALIURE_&amp;_VALUE 中的配置要求 Expression 与 Constraint 同时成立。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201343628288.png"/></p><p>SCR_SHOW_FALIURE_OR_VALUE 中的配置要求 Expression 与 Constraint 有一个成立。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201403623322.png"/></p><p>当 EST_SELECT_VALUE 中的 SQL 为 SELECT 1/0 AS A 时，执行状态 = Failure，PV_RESULT 为 EMPTY 空字符串。</p><p>所以 SRC_SHOW_SUCCESS_OR_EMPTY 满足 PV_RESULT =="" 条件，而 SCR_SHOW_FAILURE_OR_VALUE 满足 执行结果 = Failure。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052201511596686.png"/></p><p>当 EST_SELECT_VALUE 中的 SQL 为 SELECT 1 AS A 时，执行状态 = Success，PV_RESULT 为 1。</p><p>所以 SRC_SHOW_SUCCESS_OR_EMPTY 满足执行状态 = SUCCESS 条件，而 SCR_SHOW_FAILURE_OR_VALUE 满足 PV_RESULT !=""。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052202038476597.png"/></p><h2 id="articleHeader6">多约束的情况</h2><p>SCR_ALL_TRUE 受 EST_SELECT_VALUE_1 和 EST_SELECT_VALUE_2 共同影响。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052202191758979.png"/></p><p>默认情况下 SCR_ALL_TRUE 的两个优先约束都是如下图所示，这种多约束的情况要表示的意思是。从 EST_SELECT_VALUE_1 到 SCR_ALL_TRUE 只有一个结果就是 True 或者 False，这个 True 或者 False 是由 EST_SELECT_VALUE_1 中的 Constraint/Expression/Constraint and Expression/Constraint or Expression 最终结果得到的 - True 或 False。同样 EST_SELECT_VALUE_2 也能得到一个最终的计算结果 - True 或 False。</p><p>也就是说有多个条件约束对 SCR_ALL_TRUE 起约束作用，那么如何实现两种约束共同作用于 SCR_ALL_TRUE 呢？就是下面的 Multiple Constraints 中的 Logical AND 或者 Logical OR 选项来决定的了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052202284729086.png"/></p><h3 id="articleHeader7">测试条件 1</h3><ol><li>EST_SELECT_VALUE_1 - SQL = SELECT 1 AS A</li><li>EST_SELECT_VALUE_2 - SQL = SELECT 1 AS A</li><li>Logical AND (虽然是两条约束线，但是更改其中一条，另外一条也会自动更改，也就是说必须同时为 Logical AND 或者 Logical OR)。</li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052202460345884.png"/></p><h3 id="articleHeader8">测试条件 2</h3><ol><li>EST_SELECT_VALUE_1 - SQL = SELECT 1 AS A</li><li>EST_SELECT_VALUE_2 - SQL = SELECT 1/0 AS A</li><li>Logical AND</li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052202582848493.png"/></p><h3 id="articleHeader9">测试条件 3</h3><ol><li>EST_SELECT_VALUE_1 - SQL = SELECT 1 AS A</li><li>EST_SELECT_VALUE_2 - SQL = SELECT 1/0 AS A</li><li>Logical OR</li></ol><p>线条同时变为虚线，执行成功！</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052203358001423.png"/></p><h3 id="articleHeader10">测试条件 4</h3><ol><li>EST_SELECT_VALUE_1 - SQL = SELECT 1 AS A</li><li>EST_SELECT_VALUE_2 - SQL = SELECT 1/0   AS A  (Constraint - Completion)</li><li>Logical OR</li></ol><p>线条同时变为虚线，执行成功！</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052203557697622.png"/></p><h3 id="articleHeader11">测试条件 5</h3><ol><li>EST_SELECT_VALUE_1 - SQL = SELECT 1 AS A</li><li>EST_SELECT_VALUE_2 - SQL = SELECT 1/0   AS A  (Constraint - Completion)</li><li>Logical AND  执行成功！</li></ol><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052204127069062.png"/></p><h2 id="articleHeader12">PS 小窍门</h2><p>为了更清楚的知道条件表达式和约束的内容，我们可以通过设置约束线的属性让这些信息显示出来，而不是通过人工注释的方式。</p><p>选中 Constraint 线，修改其 ShowAnnotation 属性，将 AsNeeded 修改为 ConstraintOptions。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052204457695231.png"/></p><p>这样就可以清楚的看到约束中的状态判断和表达式判断了！</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201410/052204544419980.png"/></p><h2 id="articleHeader13">总结</h2><p>以上就是 Precedence Constraint 的全部内容！虽然感觉内容比较多，但是这些配置条件在不同的情形中的确会碰到。比如在文件归档任务中，就有类似于这样的条件约束。一种是只要前面加载数据成功就归档，一种是不管前面数据加载成功不成功只要执行完毕就执行归档操作。<br/></p>
</div>]
</body>
</html>
