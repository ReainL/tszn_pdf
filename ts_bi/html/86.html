
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>基于数据仓库上的 SSRS 报表展示，一般可以直接通过 SQL 查询，存储过程，视图或者表等多种方式将数据加载并呈现在报表中。但是如果是基于 Cube 多维数据集的数据查询，就不能再使用 SQL 的语法了而应该使用 MDX 查询。</p><h2 id="articleHeader2">原型介绍</h2><p>这是我们要实现的报表效果，使用的数据库示例是 MDX Step by Step 2008 的 SSAS DEMO 数据库。</p><p>收起的效果 - 按 Product Category 分组聚合并呈现所有财年的销售情况。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09203143-62796f1e45fe4535a4e0f5b942fa163c.png"/></p><p>展开之后能够看到 Product Sub Category 的销售数据。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09203155-341df4aa22ad44efb9645ba94f73df5a.png"/></p><p>通俗一点的讲，从数据仓库到 Cube 的过程就是将平面数据立体化的过程，在这个过程中加入了从各个不同角度对数据的聚合。而从 Cube 到 SSRS 报表的过程又恰恰相反将立体化的数据平面化的结果。</p><p>分析上面的需求，其中需要娶到 Category, Subcategory, Calendar Year 以及 Reseller Sales Amount 的数据。SSRS 报表可以对平面化的数据非常快速的分组和聚合的，因此上面的需求我们整理一下就得到了这样的一个数据表原型。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09203707-578774ee5672445bb61594b6d97c35fb.png"/></p><p>假设我们基于上面的这张表去创建 Cube 的话，很显然 Cube Dimension 应该包含了 Product 和 Date 这两个维度和一个度量值维度- Reseller Sales Amount ， 每一个维度的属性层次结构可以理解为在 Cube 空间中的一个轴。因此，Product 这个维度至少可以分出 Product Category 和 Product Sub Category 这两个属性层次结构，Date 维度我们假设这里只有 Calendar Year 这一个属性层次结构，那么再加上度量值维度就构成了 Cube 空间的四条轴，四条轴交汇定位到空间的一个点，这个点是一个单元格，它包含了 Reseller Sales Amount 的值。</p><p>这是从 Cube 空间体的角度来阐述从 DW 到 Cube 的变化，但是 SSRS 中表格数据中只支持二维数据组合，因此要把 Cube 空间的立体数据给拉平了再呈现回来。</p><h2 id="articleHeader3">SSRS 中的实现</h2><p>创建报表并新建数据源，这时的数据源连接方式与之前连接到 SQL Server 数据库不同，连接的是 Analysis Services 。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09210011-e06c96442535409c8188de4eeba09c1f.png"/></p><p>新建 Dataset，并且指定刚才新建的数据源。因为数据源的改变，SSRS Dataset 中的 Query Designer 将对应的调整为支持 MDX 查询的界面。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09210200-27533d535fd0467088eb6ef29a6ca424.png"/></p><p>Query Designer 中可以看到指定的分析服务的数据库以及各维度，层次结构和度量值组。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09211209-1edb195b91c94dbfb71d5f0b203b3eeb.png"/></p><p>也支持编写 MDX 查询代码，特别是比较复杂的业务逻辑的情况下，就需要自己手工编写 MDX 查询。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09211339-786ba64ceb81404a9089e681154c7499.png"/></p><p>我们直接使用拖拽的方式快速开发一个 MDX 查询报表，并且现在要做的就是让这几条轴交汇一下来展现我们扁平化的数据表原型。记住：每一个属性层次结构就是一条轴，包括度量值维度。这几条空间里的轴在数据表上最直接的反映就是形成列，每一条数据的形成就是四条轴在 Cube 空间交互的结果。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09211904-5cece0a4690c4d4ab273c95c9ed1d8a8.png"/></p><p>保存之后，看到 MDX 查询已经自动编写好了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09211950-d71eb491fa01459c8571077e0ab00346.png"/></p><p>整理一下格式，看看这个 MDX 查询是怎么写的。</p><pre><code><span style='font-family: "Microsoft Yahei";'> <span style="color: rgb(0, 0, 255);">SELECT</span> NON EMPTY { <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Measures</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Reseller Sales Amount</span><span style="color: rgb(255, 0, 0);">]</span> } <span style="color: rgb(0, 0, 255);">ON</span><span> COLUMNS, <br/>
        NON EMPTY { <br/>
                    (<br/>
                        </span><span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Date</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span><span>.ALLMEMBERS <br/>
                    ) <br/>
                  } DIMENSION PROPERTIES MEMBER_CAPTION, MEMBER_UNIQUE_NAME </span><span style="color: rgb(0, 0, 255);">ON</span><span> ROWS <br/>
</span><span style="color: rgb(0, 0, 255);">FROM</span> <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Chapter 3 Cube</span><span style="color: rgb(255, 0, 0);">]</span><span> <br/>
CELL PROPERTIES VALUE, BACK_COLOR, FORE_COLOR, FORMATTED_VALUE, FORMAT_STRING, <br/>
FONT_NAME, FONT_SIZE, FONT_FLAGS</span></span></code></pre><p>去掉一些不关键的属性，简化一下就是 -</p><pre><code><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span> NON EMPTY { <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Measures</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Reseller Sales Amount</span><span style="color: rgb(255, 0, 0);">]</span> } <span style="color: rgb(0, 0, 255);">ON</span><span> COLUMNS, <br/>
       NON EMPTY { <br/>
                    (<br/>
                        </span><span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Date</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span><span>.ALLMEMBERS <br/>
                    ) <br/>
                  }</span><span style="color: rgb(0, 0, 255);">ON</span><span> ROWS <br/>
</span><span style="color: rgb(0, 0, 255);">FROM</span> <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Chapter 3 Cube</span><span style="color: rgb(255, 0, 0);">]</span>  </span></code></pre><p>与前面在 Query Designer 上的查询结果相比一下这个 MDX 查询在 SQL Server Analysis Service 上面的查询结果，Query Desinger 的查询结果扁平化了，更容易理解成一个普通的数据表。而在这里，列头的构成比较复杂，它本想描述一下这种立体的感觉，无奈在二维平面的世界里它也描述不出来。</p><p>注意，这里的 MDX 查询在 Columns 只能是 Measure 度量值。 </p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09212658-4f118a2f55b04d06894e893508756f29.png"/></p><p>创建好了 Dataset 之后就可以直接使用这个平面数据了，拖放一个 Matrix 过来。Matrix 和 Tabular 最大的区别就是 Matrix 可以直接形成行和列的聚合。</p><p>对比一下拖放之间和拖放之后的 Matrix 格局便于大家理解。Row 上放的应该是 Category 和 Subcategory，列上放的应该是 Calendar Year，被聚合的数据应该是 Reseller Sales Amount。但是这里，我们先放 Subcategory，然后在 Subcategory 基础上添加 Group - Category。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09213150-ca324224214a4301985eeba12b75dc2b.png"/></p><p>选中 Subcategory 然后右键添加一个 Group - Parent Group 。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09213700-697ecb27b8fb4b0494156ea2426ddd67.png"/></p><p>Product Subcategory 可以按照 Category 分组，添加一个 Group Header。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09213718-1754228c8773467ca12b87a3f3bba9cf.png"/></p><p>添加完了之后的效果，不过接着就应该删除 Category 这一列，让 Category 这个元素显示在 Subcategory 元素之上，并且添加 Category 级别对 Reseller Sales Amount 的 SUM 聚合。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09213728-06abfcc00fa14e93a46588d116e8fd98.png"/></p><p>对比上下这种变化，基本上就完成了报表数据的分组聚合设计。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09214155-56e36b3a36f64f2db77f5c44267f9f6d.png"/></p><p>接着调整一下，然后上色。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09215008-1aec6b7f7b934bf28f9290fc8a844c6a.png"/></p><p>为 Category 添加一个 Total。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09215036-7e879bdbf9154e9b988fd6a69b3f9b44.png"/></p><p>基于 Calendary Year 也添加一个 Total。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09215050-835e8bb0bd734b40b0977bcbce6d0719.png"/></p><p>添加完了后上上色，调整一下格式。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09215147-9a50048f098342b7bf0345b01be94a07.png"/></p><p>将标题 Subcategory 改成 Category ，并且设置 Subcategory 按照 Category 的点击来展现收缩和展开效果。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09215812-6d8d0a6d427a4b1087de696d705bdd5a.png"/></p><p>自此就已经完成了一个简单的 MDX 查询在 SSRS 报表上的展现。不过，如果要添加参数比如希望能够先筛选 Category 和 Subcategory，回到 Dataset 里的 Query Designer 添加 Parameter 。</p><p><img alt="" height="581" src="http://images.cnitblog.com/blog/477275/201310/09220246-5b856e872ef74a078781acaaad4b2a59.png" width="868"/></p><p>保存并刷新，SSRS 为自动创建两个参数。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09220412-fb6594482fc4484cae7fa07387041c16.png"/></p><p>预览报表并选择参数。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09220432-aaebda2d6c6d44c582325a9f2ce1b500.png"/></p><p>最后查询出来的结果。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09220451-435d0e2dce384d11a5be3aa61dc6c1b7.png"/></p><h2 id="articleHeader4">MDX 查询分析</h2><p>分析一下在 Query Builder 中的 MDX 查询语句，我就以 MDX Step By Step 上面的例子来说吧，这个 MDX 查询在 SSAS 查询分析器中没有问题。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09220912-a7c97535b64a4bc492e08c41d9ff1e06.png"/></p><p>但是同样的语句放到 Query Designer 中就有问题，提示这种错误。</p><p><span style="color: rgb(255, 0, 0);">The query cannot be prepared: The query must have at least one axis. The first axis of the query should not have multiple hierarchies, nor should it reference any dimension other than the Measures dimension..</span> <span style="color: rgb(255, 0, 0);">Parameter name: mdx (MDXQueryGenerator)</span></p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09221126-ee84fc34bac3493a85a8db4ca71cba47.png"/></p><p>其中要注意的有三点：</p><ul><li>MDX Query 必须至少要有一个轴。</li><li>第一个轴中的查询不能包含多个层次结构，只能有一个。</li><li>除了 度量值维度 Measure Dimension 之外不能引用其它任何的维度。</li></ul><p>再来看看我们的带参数的 MDX 查询语句。</p><pre><code><span style='font-family: "Microsoft Yahei";'><span style="color: rgb(0, 0, 255);">SELECT</span>  <span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> COLUMNS 轴也就是第一个轴上的维度是度量值维度</span><br/>
        NON EMPTY { <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Measures</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Reseller Sales Amount</span><span style="color: rgb(255, 0, 0);">]</span> } <span style="color: rgb(0, 0, 255);">ON</span><span> COLUMNS, <br/>
        </span><span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> ROWS 上由多个属性层次结构的成员构成 SET 集</span><br/>
<span>        NON EMPTY { <br/>
                    (<br/>
                        </span><span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Category</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Product</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Subcategory</span><span style="color: rgb(255, 0, 0);">]</span>.ALLMEMBERS <span style="color: rgb(128, 128, 128);">*</span> <br/>
                        <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Date</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span>.<span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Calendar Year</span><span style="color: rgb(255, 0, 0);">]</span><span>.ALLMEMBERS <br/>
                    ) <br/>
                  }</span><span style="color: rgb(0, 0, 255);">ON</span><span> ROWS <br/>
</span><span style="color: rgb(0, 0, 255);">FROM</span> <br/>
<span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> 第三层查询基于前两层查询筛选之后的结果</span><br/>
<span>( <br/>
    </span><span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> 第二层查询，根据参数 Product Subcategory 并根据第一层查询的结果返回相应的 Subcategory</span><br/>
    <span style="color: rgb(0, 0, 255);">SELECT</span> ( STRTOSET(<span style="color: rgb(0, 128, 0);">@ProductSubcategory</span>, CONSTRAINED) ) <span style="color: rgb(0, 0, 255);">ON</span><span> COLUMNS <br/>
    </span><span style="color: rgb(0, 0, 255);">FROM</span><span> ( <br/>
            </span><span style="color: rgb(0, 128, 128);">--</span><span style="color: rgb(0, 128, 128);"> 第一层查询，根据参数 Product Category 决定了这个层次结构上所有的 Category 成员</span><br/>
            <span style="color: rgb(0, 0, 255);">SELECT</span> ( STRTOSET(<span style="color: rgb(0, 128, 0);">@ProductCategory</span>, CONSTRAINED) ) <span style="color: rgb(0, 0, 255);">ON</span><span> COLUMNS <br/>
            </span><span style="color: rgb(0, 0, 255);">FROM</span> <span style="color: rgb(255, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">Chapter 3 Cube</span><span style="color: rgb(255, 0, 0);">]</span><span><br/>
         )<br/>
) </span></span></code></pre><p>其中最重要的就是 STRTOSET 函数的使用，在 SSRS 加载的时候会首先列出所有 Product Category 成员供我们选择。 <img alt="" src="http://images.cnitblog.com/blog/477275/201310/09223807-327ea6451baa49a6a1f6a18d5ea54539.png"/></p><p> </p><p>就相当于 -</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09224601-8a5424104360420c8d5d417ea32c625d.png"/></p><p>选择完了 Bikes 之后，Subcategory 刷新完然后选择 Mountain Bikes 和 Road Bikes</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09223830-ee6ae7d1191048049775b08e4298c1ba.png"/></p><p>就相当于</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09224727-4bc96ee17afe4daab314e8112aa6fc75.png"/></p><p>整个 MDX 查询翻译到 SSAS 的就是</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09224804-da3a59dd93cb49d38c3adee27d2de2e0.png"/></p><p>对比一下最终在 SSRS 上的报表，相当于把 MDX Query 的结果给扁平化了。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09224855-ca79d8d985c2407c8bd1b2b109f098f9.png"/></p><p>要注意的是 STRTOSET(<span style="color: rgb(163, 21, 21);">'[Product].[Category].[Bikes]'</span>, <span style="color: rgb(0, 0, 255);">CONSTRAINED</span>)，它将一个字符串转化成了一个具体的集合，并且加上了 <span style="color: rgb(0, 0, 255);">CONSTRAINED</span> 那么在第一个参数字符串中就只能指定具体的层次结构中的成员，它有一个限定作用。</p><p>比如说如果想直接写上全部成员就会发生这样的错误。</p><p><span style="color: rgb(255, 0, 0);">The restrictions imposed by the CONSTRAINED flag in the STRTOSET function were violated.</span></p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09225359-35888a6b4255486aa807696a622c6d33.png"/></p><p>如果去掉 <span style="color: rgb(0, 0, 255);">CONSTRAINED</span>，那么结果是OK的，类似的函数还有 STRTOMEMBER.</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201310/09225600-066f0dbc3e514c5abd13c7cd26bc757a.png"/></p><p>至于 STRTOSET 和 STRTOMEMBER 这两个 MDX 函数就不在这篇 SSRS 博客中详细解释了，这里只是通过例子对比大概描述了 MDX 查询参数化的过程和在 SSRS 报表上的使用。这种方式非常直接也比较简单，当然也还有其它传参数的方式，比如编写 Expression 等等在不同的场景下也会使用到。</p><p>没有写好的地方，欢迎大家积极补充和指正！</p>
</div>]
</body>
</html>
