
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
[<div class="message-content editor-style">
<h2 id="articleHeader1">开篇介绍</h2><p>在 SSIS Dataflow 数据流中的组件可以分为 Synchronous 同步和 Asynchronous 异步这两种类型。</p><h2 id="articleHeader2">同步与异步 Synchronous and Asynchronous</h2><h3 id="articleHeader3">Synchronous 同步组件</h3><p>同步组件有一个非常重要的特征 - 同步组件的输出和它的输入共享同一个缓存，即输入多少行数据输出就多少行数据。在同步转换的过程中，输入一行，输出一行，输入与输出同步，它们同时发生。</p><h3 id="articleHeader4">Asynchronous 异步组件</h3><p>异步组件的特征就是它的输出使用的是一个新的缓存，它不会重用输入的缓存，输出的记录有可能比输入多，也有可能比输入少。在异步转换的过程中，异步组件会要求新的缓存区才会执行处理，比如向 Sort 组件，它必须要在一个操作中处理整个行集。还有像 Merge, Merge Join 等合并操作，组件要先检查各个输入的多个行，然后按照排序好的顺序来合并输入行。包括 Aggregate 组件，它需要新添加一行来保存计算好的聚合值。 </p><p>所以这样对比下来，通常情况下同步组件因为可以重用输入的缓存因此要比异步组件要快一些，因为异步组件需要一块新的缓存来完成输出内容。</p><p>观察所有的数据源组件，它们都是异步类型，因为它们需要创建两个缓存，一个是成功的输出一个是错误输出，所有的目标 Destination 组件都是同步的。</p><h2 id="articleHeader5">阻塞，半阻塞和全阻塞 (Non-blocking, semi-blocking and Fully-blocking)</h2><p>除了上面的两种分类之外，还可以将它们分为这三种类型：Non-blocking 非阻塞, semi-blocking 半阻塞和 Fully-blocking 全阻塞。 </p><h3 id="articleHeader6">Non-blocking 非阻塞转换</h3><p>非阻塞转换也被称为行转换，也属于同步转换组件。组件接收到一行数据，对这一行数据处理后再输出。在组件的整个输出处理过程中不新建也不删除数据行。比如从上游 Source 中加载1000条数据，经过非阻塞转换组件的时候，每接收一行数据就处理一行，处理完毕后就直接将这一行数据传递给下游组件，不会等到所有的1000条数据处理完才交给下一个组件。</p><h3 id="articleHeader7">Semi-blocking 半阻塞转换</h3><p>半阻塞的意思就是转换组件会控制输入行一段时间，比如组件接收到上游的1000行数据，有可能接收到了10行或者100行数据就汇总一次，最后输出这10行或者100行数据，或者输出一行汇总的数据，所以每次接到一行数据并不会立即处理输出。处理完这批数据输出之后，就可以继续接受其它行数据并处理再输出，半阻塞转换也属于异步转换组件。</p><h3 id="articleHeader8">Fully-blocking 全阻塞转换</h3><p>与半阻塞转换相同，都是属于异步转换组件。但是全阻塞转换组件会控制全部数据，上游来了1000行数据，全阻塞组件需要接受完全部的1000行数据之后才会处理输出。比如像 Sort 或者 Aggregate 组件，它们需要接受了所有数据之后才会排序或者聚合，这个是很容易理解的。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/20004433-dcd4e254d0504109a12c7fa37f96037b.png"/></p><h2 id="articleHeader9">SSIS 数据流 Data Flow 组件中的分类</h2><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/20004443-7fb5cfb9b3aa45c1893950557f635d39.png"/></p><h3 id="articleHeader10">如何理解 Buffer 缓存 </h3><p>Buffer 缓存实际上可以理解为数据流中存储数据的容器，再说简单一点就是一块内存，数据流组件从外部获取数据之后数据就保存在这个 Buffer 容器。一个 Data Flow Task 中可以有多个 Buffer, 并且要理解的是 一个 Buffer 并不是由单个组件独有，而是可以由几个转换组件共享。在整个数据流中，每遇到一个异步输出就会新创建一个 Buffer。</p><p><img alt="" src="http://images.cnitblog.com/blog/477275/201309/20004527-031a586173a94815ae71444cee72b5d8.png"/> </p><p> </p><p>看一个示例，这个数据流从 OLE DB Source 组件开始 (OLE_SRC_UserDownload) 开启一个 Buffer 容器，它是异步组件它需要开辟这个新缓存。Multicast 组件 (MC_UserDownload) 与 OLE DB Destination (OLE_DST_UserDownload) 它们是同步组件，因此它们不需要新创建缓存，因此是与它们的输入即 OLE_SRC_UserDownload 共享这个 Buffer，如图所示 Buffer 1 部分。</p><p>通过 Multicast 组件，产生了左右两个分支，当遇到 Aggregate 组件 (Aggregate_Count_MaxLoadingTime) 时，因为 Aggregate 组件是一个异步完全阻塞组件，因此需要创建一个新的缓存 Buffer 容器 - Buffer 2。</p><p>在 Buffer 2 中，假设通过 Aggregate_Count_MaxLoadingTime 往下产生了两列，那么 Buffer 2 中就定义了这两列，当通过 Derived Column 组件 (DC_CreateAuditColumns) 衍生新的两列时，此时 Buffer 2 就多定义了两列，总共就定义了四列，当所有数据写入 OLE DB Destination 组件之后 Buffer 2 也就结束了。</p><p>了解了有关 Buffer 的知识之后，可以打开所在数据流的属性，能看到对当前数据流 Buffer 容器相关属性的配置，比如默认缓存中的最大行数，默认缓存大小。默认缓存大小是10 MB，一个 Buffer 中最大只能处理 100 MB 数据，所以也可以设置成 100 MB，但是如果处理的数据超过100MB数据流就会多建几个 Buffer。</p><p> </p><p> <img alt="" src="http://images.cnitblog.com/blog/477275/201309/20004602-38ccdb45b73646f8acdbc4068e206e94.png"/><br/><br/></p>
</div>]
</body>
</html>
